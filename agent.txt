######################
# FILE: .env.example #
######################

# Core LLM settings
LLM_MODEL=gpt-4o-mini
LLM_API_KEY=sk-***
LLM_API_BASE=https://api.openai.com/v1

# External MCP services
DB_MCP_URL=http://localhost:28001/mcp
GOSPLAN_MCP_URL=http://localhost:28003/mcp

# Agent metadata and server config
AGENT_NAME=PurchaseMatcher
AGENT_DESCRIPTION="Агент подбирает закупки ЕИС для заданной компании по профилю и запросу"
AGENT_HOST=0.0.0.0
AGENT_PORT=8002
AGENT_URL=http://0.0.0.0:8002
AGENT_VERSION=v1.0.0

# Optional logging
LOG_LEVEL=INFO


#########################
# FILE: src/__init__.py #
#########################



############################
# FILE: src/a2a_wrapper.py #
############################

"""Обертка LangChain агента PurchaseMatcher для A2A протокола."""

import re
import json
import asyncio
import logging
from typing import Dict, Any, AsyncGenerator, List

from langchain_core.messages import HumanMessage, AIMessage, BaseMessage

logger = logging.getLogger(__name__)

_THINK_BLOCK_RE = re.compile(r"<think>.*?</think>", re.DOTALL | re.IGNORECASE)
_RESET_TOKEN = "<RESET_CONTEXT>"


def _strip_think_blocks(text: str) -> str:
    """Удаляет из ответа скрытые блоки размышлений `<think>...</think>`."""
    if not text:
        return text
    return _THINK_BLOCK_RE.sub("", text).strip()


def _strip_reset_token(text: str) -> tuple[str, bool]:
    """Удаляет служебный маркер <RESET_CONTEXT>, возвращает (чистый_текст, был_ли_маркер)."""
    if not text:
        return text, False

    had_token = _RESET_TOKEN in text
    if not had_token:
        return text, False

    cleaned = text.replace(_RESET_TOKEN, "").strip()
    return cleaned, True


def _looks_like_jsonl(text: str) -> bool:
    """
    Проверяет, что ответ — чистый JSONL:
    - есть хотя бы одна непустая строка;
    - КАЖДАЯ непустая строка парсится как корректный JSON-объект.
    """
    if not text:
        return False

    lines = [line for line in text.splitlines() if line.strip()]
    if not lines:
        return False

    try:
        for line in lines:
            obj = json.loads(line)
            if not isinstance(obj, dict):
                return False
        return True
    except Exception:
        return False


class LangChainA2AWrapper:
    """Обертка для преобразования LangChain агента PurchaseMatcher в A2A-интерфейс."""

    # Для совместимости с A2A
    SUPPORTED_CONTENT_TYPES = ["text", "text/plain"]

    def __init__(self, agent_executor, auto_reset_on_complete: bool = True) -> None:
        self.agent_executor = agent_executor
        # история как список BaseMessage (HumanMessage / AIMessage)
        self.sessions: Dict[str, List[BaseMessage]] = {}
        # включаем/выключаем автоочистку сессии после завершения задачи
        self.auto_reset_on_complete = auto_reset_on_complete

    def _get_session_history(self, session_id: str) -> List[BaseMessage]:
        """Получает историю сессии для подстановки в MessagesPlaceholder(chat_history)."""
        if session_id not in self.sessions:
            self.sessions[session_id] = []
        return self.sessions[session_id]

    def _reset_session(self, session_id: str) -> None:
        """Полностью сбрасывает историю для сессии (логическое завершение контекста)."""
        if session_id in self.sessions:
            del self.sessions[session_id]
            logger.debug("Session %s has been reset (task complete).", session_id)

    def _postprocess_output(self, raw_output: str) -> tuple[str, bool, bool]:
        """
        Применяет все пост-обработки и возвращает:
        - clean_output: текст без <think> и служебных маркеров,
        - is_final_jsonl: является ли текст финальным JSONL-результатом,
        - reset_context: нужно ли сбросить контекст (<RESET_CONTEXT> был найден).
        """
        without_think = _strip_think_blocks(raw_output)
        cleaned, had_reset = _strip_reset_token(without_think)
        is_jsonl = _looks_like_jsonl(cleaned)
        return cleaned, is_jsonl, had_reset

    async def invoke(self, query: str, session_id: str) -> Dict[str, Any]:
        """Синхронный (не-стриминговый) вызов агента."""
        try:
            chat_history = self._get_session_history(session_id)

            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                None,
                lambda: self.agent_executor.invoke(
                    {
                        "input": query,
                        "chat_history": chat_history,
                    }
                ),
            )

            if isinstance(result, dict):
                raw_output = result.get("output", "")
            else:
                raw_output = str(result)

            clean_output, is_final_jsonl, reset_context = self._postprocess_output(raw_output)

            # обновляем историю диалога
            if query:
                chat_history.append(HumanMessage(content=query))
            if clean_output:
                chat_history.append(AIMessage(content=clean_output))

            # критерии завершения:
            # - если был служебный маркер <RESET_CONTEXT> → задача завершена, контекст сбрасываем;
            # - если ответ — чистый JSONL → считаем, что это финальный результат и задача завершена.
            is_task_complete = bool(is_final_jsonl or reset_context)

            # пока не финальный JSONL и не RESET_CONTEXT — ожидаем ответ пользователя
            require_user_input = not is_task_complete and bool(clean_output and clean_output.strip())

            response = {
                "is_task_complete": is_task_complete,
                "require_user_input": require_user_input,
                "content": clean_output,
                "is_error": False,
                "is_event": False,
            }

            if self.auto_reset_on_complete and is_task_complete:
                self._reset_session(session_id)

            return response

        except Exception as e:
            logger.exception("Error in LangChainA2AWrapper.invoke")
            return {
                "is_task_complete": True,
                "require_user_input": False,
                "content": f"Ошибка: {str(e)}",
                "is_error": True,
                "is_event": False,
            }

    async def stream(self, query: str, session_id: str) -> AsyncGenerator[Dict[str, Any], None]:
        """Стриминговый вызов агента."""
        try:
            chat_history = self._get_session_history(session_id)
            logger.info(
                "LC-A2A stream: session_id=%s, history_len(before)=%d",
                session_id,
                len(chat_history),
            )

            full_response = ""

            async for chunk in self.agent_executor.astream(
                {
                    "input": query,
                    "chat_history": chat_history,
                }
            ):
                if not isinstance(chunk, dict):
                    continue

                # Поток основного текста
                if "output" in chunk and isinstance(chunk["output"], str):
                    delta = chunk["output"]
                    if delta:
                        full_response += delta
                        # Промежуточные токены — просто "working", без ожидания ввода
                        yield {
                            "is_task_complete": False,
                            "require_user_input": False,
                            "content": delta,
                            "is_error": False,
                            "is_event": False,
                        }

            # После окончания стрима обрабатываем накопленный ответ
            clean_full, is_final_jsonl, reset_context = self._postprocess_output(full_response)

            # Обновляем историю диалога
            if query:
                chat_history.append(HumanMessage(content=query))
            if clean_full:
                chat_history.append(AIMessage(content=clean_full))

            logger.debug(
                "LC-A2A stream: session_id=%s, history_len(after)=%d",
                session_id,
                len(chat_history),
            )

            is_task_complete = bool(is_final_jsonl or reset_context)
            require_user_input = not is_task_complete and bool(clean_full and clean_full.strip())

            if not full_response or clean_full != full_response:
                final_payload = {
                    "is_task_complete": is_task_complete,
                    "require_user_input": require_user_input,
                    "content": clean_full,
                    "is_error": False,
                    "is_event": False,
                }
            else:
                # Весь текст уже ушёл стримом, финальное сообщение — только статус
                final_payload = {
                    "is_task_complete": is_task_complete,
                    "require_user_input": require_user_input,
                    "content": "",
                    "is_error": False,
                    "is_event": False,
                }

            if self.auto_reset_on_complete and is_task_complete:
                self._reset_session(session_id)

            # Отдаём финальное сообщение
            yield final_payload

        except Exception as e:
            logger.exception("Error in LangChainA2AWrapper.stream")
            yield {
                "is_task_complete": True,
                "require_user_input": False,
                "content": f"Ошибка: {str(e)}",
                "is_error": True,
                "is_event": False,
            }


######################
# FILE: src/agent.py #
######################

######################
# FILE: src/agent.py #
######################

"""Определение LangChain агента PurchaseMatcher с поддержкой MCP инструментов (classic API)."""

from __future__ import annotations

import asyncio
import sys
import types
from typing import List, Optional, Dict

from langchain_openai import ChatOpenAI
from langchain_core.tools import BaseTool
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder

# ВАЖНО: классический AgentExecutor и tool-calling агент
from langchain_classic.agents import AgentExecutor, create_tool_calling_agent

# Хак для langchain_mcp_adapters (как в профайлере)
def _ensure_langchain_content_module() -> None:
    """Ensure langchain-mcp-adapters can import ``langchain_core.messages.content``."""
    if "langchain_core.messages.content" in sys.modules:
        return

    try:
        from langchain_core.messages import content_blocks
    except Exception:
        return

    shim = types.ModuleType("langchain_core.messages.content")
    shim.__dict__.update(content_blocks.__dict__)
    sys.modules["langchain_core.messages.content"] = shim


_ensure_langchain_content_module()

from langchain_mcp_adapters.client import MultiServerMCPClient  # MCP <-> LangChain

from config import get_settings, logger
from base_prompt import BASE_SYSTEM_PROMPT

settings = get_settings()


def _normalize_mcp_url(raw: str) -> str:
    """Нормализует URL MCP сервера к виду .../mcp."""
    raw = (raw or "").strip()
    if not raw:
        raise ValueError("Пустой MCP URL")

    # уже /mcp или /mcp/
    if raw.rstrip("/").endswith("/mcp"):
        return raw.rstrip("/")

    return raw.rstrip("/") + "/mcp"


def _build_mcp_client(mcp_urls: Optional[str]) -> Optional[MultiServerMCPClient]:
    """
    Создаёт MultiServerMCPClient по строке с MCP URL-ами.

    Поддерживаем форматы:
      - "http://db-mcp:28001/mcp"
      - "http://db-mcp:28001"
      - "db=http://db-mcp:28001/mcp"
      - "db=http://db-mcp:28001,gosplan=http://gosplan-mcp:28002/mcp"
    """
    if not mcp_urls:
        return None

    servers: Dict[str, dict] = {}

    for idx, item in enumerate(mcp_urls.split(",")):
        item = item.strip()
        if not item:
            continue

        if "=" in item:
            name, url = item.split("=", 1)
            name = name.strip() or f"mcp_{idx}"
            url = url.strip()
        else:
            name = f"mcp_{idx}"
            url = item.strip()

        if not url:
            continue

        url = _normalize_mcp_url(url)

        servers[name] = {
            "transport": "streamable_http",
            "url": url,
        }

    if not servers:
        return None

    return MultiServerMCPClient(servers)


async def _get_mcp_tools_async(mcp_urls: Optional[str]) -> List[BaseTool]:
    """Асинхронная загрузка всех тулов со всех MCP-серверов."""
    client = _build_mcp_client(mcp_urls)
    if client is None:
        return []

    tools = await client.get_tools()
    return list(tools)


def get_mcp_tools(mcp_urls: Optional[str]) -> List[BaseTool]:
    """Синхронная обёртка над асинхронной загрузкой MCP-тулов."""
    if not mcp_urls:
        return []
    return asyncio.run(_get_mcp_tools_async(mcp_urls))


def create_langchain_agent(
    mcp_urls: str | list[str] | None = None,
) -> AgentExecutor:
    """
    Создаёт классический LangChain-агент PurchaseMatcher с MCP инструментами.

    Возвращаем именно AgentExecutor:
    - astream_events / ainvoke / invoke
    - return_intermediate_steps и т.д.
    Это совместимо с твоей A2A-обёрткой (как в профайлере).
    """
    logger.info("LLM: model=%s base_url=%s", settings.llm_model, settings.llm_api_base)

    # защита от префикса hosted_vllm/ (как в профайлере)
    settings.llm_model = settings.llm_model.replace("hosted_vllm/", "")

    # LLM
    llm = ChatOpenAI(
        model=settings.llm_model,
        base_url=settings.llm_api_base,
        api_key=settings.llm_api_key,
        temperature=0.1,
    )

    # Инструменты MCP (db-mcp, gosplan-mcp и др.)
    mcp_tools: List[BaseTool] = []

    if isinstance(mcp_urls, list):
        for url in mcp_urls:
            mcp_tools.extend(get_mcp_tools(url))
    elif isinstance(mcp_urls, str):
        mcp_tools.extend(get_mcp_tools(mcp_urls))
    else:
        # MCP не настроены
        pass

    logger.info("Loaded %d MCP tools", len(mcp_tools))

    # Системный промпт (как ты его уже прописал под PurchaseMatcher)
    system_prompt = BASE_SYSTEM_PROMPT

    # ВАЖНО: структура промпта под классический tool-calling агент
    prompt = ChatPromptTemplate.from_messages(
        [
            ("system", "{system_prompt}"),
            MessagesPlaceholder(variable_name="chat_history", optional=True),
            ("human", "{input}"),
            MessagesPlaceholder(variable_name="agent_scratchpad"),
        ]
    ).partial(system_prompt=system_prompt)

    # Классический tool-calling агент
    agent = create_tool_calling_agent(
        llm=llm,
        tools=mcp_tools,
        prompt=prompt,
    )

    # Классический Executor (как раньше)
    agent_executor = AgentExecutor(
        agent=agent,
        tools=mcp_tools,
        verbose=True,
        handle_parsing_errors=True,
        max_iterations=24,
        return_intermediate_steps=True,
    )

    return agent_executor


###################################
# FILE: src/agent_task_manager.py #
###################################

import logging
from a2a.server.agent_execution import AgentExecutor as A2AAgentExecutor, RequestContext
from a2a.server.events import EventQueue
from a2a.server.tasks import TaskUpdater
from a2a.types import Task, TaskState, UnsupportedOperationError
from a2a.utils import new_agent_text_message, new_task
from a2a.utils.errors import ServerError
from a2a_wrapper import LangChainA2AWrapper

logger = logging.getLogger(__name__)


class LangChainAgentExecutor(A2AAgentExecutor):
    """AgentExecutor для LangChain агента."""

    def __init__(self, agent_wrapper: LangChainA2AWrapper):
        self.agent = agent_wrapper

    async def execute(
        self,
        context: RequestContext,
        event_queue: EventQueue,
    ) -> None:
        query = context.get_user_input()
        task = context.current_task

        # 1️⃣ Пытаемся взять session_id из metadata, которое прислал клиент
        session_id: str | None = None
        try:
            metadata = getattr(context, "metadata", None) or {}
            if isinstance(metadata, dict):
                session_id = metadata.get("session_id")
        except Exception:
            session_id = None

        # 2️⃣ Если клиент не прислал session_id — fallback
        if not session_id:
            session_id = (
                getattr(context, "context_id", None)
                or (getattr(task, "context_id", None) if task else None)
                or (getattr(task, "id", None) if task else None)
                or "default"
            )

        logger.info(
            "LC-A2A execute: session_id=%s, context_id=%s, task_id=%s",
            session_id,
            getattr(context, "context_id", None),
            getattr(task, "id", None) if task else None,
        )

        # 3️⃣ Создаём задачу, если её ещё нет
        if not task:
            task = new_task(context.message)
            await event_queue.enqueue_event(task)

        updater = TaskUpdater(event_queue, task.id, task.context_id)

        # 4️⃣ Стримим ответ агента
        async for item in self.agent.stream(query, session_id):
            is_task_complete = item["is_task_complete"]
            require_user_input = item["require_user_input"]
            is_error = item["is_error"]
            is_event = item["is_event"]

            if is_error:
                await updater.update_status(
                    TaskState.failed,
                    new_agent_text_message(
                        item["content"], task.context_id, task.id
                    ),
                )
                break

            if is_event:
                await updater.update_status(
                    TaskState.working,
                    new_agent_text_message(
                        item["content"], task.context_id, task.id
                    ),
                )
                continue

            if not is_task_complete and not require_user_input:
                await updater.update_status(
                    TaskState.working,
                    new_agent_text_message(
                        item["content"], task.context_id, task.id
                    ),
                )
                continue

            if not is_task_complete and require_user_input:
                await updater.update_status(
                    TaskState.input_required,
                    new_agent_text_message(
                        item["content"], task.context_id, task.id
                    ),
                )
                break

            if is_task_complete and not require_user_input:
                await updater.update_status(
                    TaskState.completed,
                    new_agent_text_message(
                        item["content"], task.context_id, task.id
                    ),
                )
                break

    async def cancel(
        self, request: RequestContext, event_queue: EventQueue
    ) -> Task | None:
        raise ServerError(error=UnsupportedOperationError())


############################
# FILE: src/base_prompt.py #
############################

BASE_SYSTEM_PROMPT = r"""
Ты — агент «PurchaseMatcher» для платформы AI Agents.

Твоя задача:
- по профилю компании из db-mcp и запросу пользователя на русском языке
- найти через gosplan-mcp наиболее подходящие закупки,
- оценить каждую по нескольким метрикам,
- отсортировать по перспективности
- и по запросу пользователя выдать результат в формате JSONL, пригодном для машинной обработки.

--------------------------------
1. Общие правила

- ВСЁ общение с пользователем веди только на естественном русском языке.
- Не выдумывай данные о компании, ОКПД2, регионах или закупках.
  Используй только то, что пришло из db-mcp и gosplan-mcp.
- Если какого-то поля нет, лучше явно обозначить это как null/«нет данных», чем придумывать значение.
- Пользовательские технические слова (ID, URL и т.п.) можно оставлять как есть.
- Никогда не придумывай URL: используй ссылки из structured_content (card_urls, href и т.п.),
  если их нет — ставь null.

--------------------------------
2. Профиль компании

Профиль компании ты НЕ создаёшь и НЕ изменяешь, а только читаешь через инструменты db-mcp.

Ожидается, что профиль содержит как минимум поля:
- id: строка
- name: строка
- description: строка (описание деятельности)
- okpd2_codes: список объектов вида:
  {
    "code": "<строковый код ОКПД2>",
    "title": "<человеческое название>"
  }
- regions_codes: список объектов вида:
  {
    "code": "<строковый код региона>",
    "title": "<человеческое название>"
  }

--------------------------------
3. Начало диалога и сбор исходных данных

При первом сообщении пользователя:
1) Кратко объясни, что ты подбираешь закупки по профилю компании.
2) Попроси пользователя дать:
   - идентификатор компании (ID), если он у него уже есть;
   - название компании (для поиска по имени);
   - краткое описание того, какие закупки нужны
     (тип товаров/услуг, примерный размер контрактов, регионы, закон и т.п.);
   - крайнюю дату, до которой должна быть ОКОНЧЕНА подача заявок
     (параметр applications_end_before, формат ГГГГ-ММ-ДД).

Правила:
- Если пользователь уже в первом сообщении указал эти данные, ты можешь не задавать лишних вопросов.
- Если дата дедлайна (applications_end_before) не указана или неочевидна,
  ОБЯЗАТЕЛЬНО задай прямой уточняющий вопрос с примером формата: ГГГГ-ММ-ДД.

--------------------------------
4. Поиск профиля компании через db-mcp

У тебя есть MCP-инструменты из db-mcp, которые позволяют:
- получить профиль по ID компании,
- искать профиль по названию компании.

Имена инструментов могут отличаться, поэтому:
- внимательно читай их описания;
- используй инструмент, который по смыслу:
  - «ищет профиль по id/идентификатору» — сначала по ID, если он указан;
  - если по ID профиль не найден или ID не указан — инструмент, который «ищет по названию».

Если поиск по имени возвращает несколько кандидатов:
- аккуратно выведи краткий список (id + название + 1–2 ключевые характеристики),
- попроси пользователя явно выбрать нужную компанию.

Если подходящий профиль НЕ найден:
- честно скажи пользователю, что профиль компании ещё не создан
  и нужно сначала воспользоваться агентом для создания профиля;
- НИ В КОЕМ СЛУЧАЕ не придумывай профиль «из головы»;
- в конце такого ответа добавь на ОТДЕЛЬНОЙ строке служебный маркер:
  <RESET_CONTEXT>

Этот маркер подсказывает платформе сбросить текущий контекст.

--------------------------------
5. Разбор профиля и пользовательского запроса

Когда профиль успешно найден:
- извлеки из него:
  - name
  - description
  - okpd2_codes (список объектов {code, title})
  - regions_codes (список объектов {code, title})

Из запроса пользователя и уточняющих вопросов ты должен получить:
- applications_end_before — дата ГГГГ-ММ-ДД.
  При отсутствии или неоднозначности — задаёшь прямой вопрос.
- возможные переопределения регионов:
  - если пользователь говорит «только Москва и МО» и т.п. —
    используй ТОЛЬКО эти регионы, даже если у компании в профиле их больше.
  - если пользователь говорит «любой регион» — значит поиск по регионам не ограничиваем.
- предпочтения по закону:
  - только 44-ФЗ,
  - только 223-ФЗ,
  - или оба (по умолчанию — оба).
- примерный диапазон цен контракта (минимум/максимум), если пользователь явно его задаёт.
- любые дополнительные ограничения, если они явно могут быть отображены в параметры поиска.

Если пользовательские ограничения конфликтуют с профилем,
ПРИОРИТЕТ у пользовательских ограничений.

--------------------------------
6. Поиск закупок через gosplan-mcp

В gosplan-mcp уже реализован инструмент поиска закупок, который:
- ищет закупки по ОКПД2 и кодам регионов,
- принимает временные ограничения по сроку окончания приёма заявок,
- ходит по 44-ФЗ и 223-ФЗ и объединяет результаты,
- возвращает список нормализованных объектов закупок (structured_content) с полями,
  вроде: law, purchase_number, max_price, currency_code, submission_close_at, region, okpd2 и т.д.

Ты НЕ знаешь точное имя инструмента, но:
- выбери в списке MCP инструментов тот, чей description явно описывает
  поиск закупок по ОКПД2, регионам и дедлайнам.

Параметры этого инструмента (по реальному gosplan-mcp):

- classifiers: List[str]
  Список ОКПД2-кодов (строки).
  Используй значение поля code из элементов okpd2_codes профиля компании.
  Если пользователь явно сузил или расширил список ОКПД2 — учитывай это.

- region_codes: List[int]
  Список числовых кодов регионов.
  Если пользователь говорит «любой регион» — передавай пустой список.
  Если профиль компании содержит регионы (строковые коды), а инструмент требует числа,
  аккуратно преобразуй их к целым числам, если это возможно.
  В случае сомнений — лучше спроси пользователя.

- collecting_finished_before: str | None
  ISO дата/время, ПОСЛЕ которого приём заявок должен ЗАКОНЧИТЬСЯ.
  Если пользователь даёт только дату ГГГГ-ММ-ДД,
  используй конец дня: "ГГГГ-ММ-ДДT23:59:59".

- collecting_finished_after: str | None
  Нижняя граница завершения приёма заявок.
  Если пользователь явно не задаёт нижнюю границу, можешь оставить этот параметр пустым.

Количество закупок (limit) в gosplan-mcp ограничивается через настройки сервера
(GOSPLAN_PURCHASES_LIMIT), поэтому:
- НЕ придумывай параметр limit, если его нет в схеме инструмента.

Если поиск ничего не нашёл:
- честно сообщи, что по текущим фильтрам закупок не найдено;
- предложи варианты ослабить фильтры (сдвинуть дедлайн, расширить регионы, убрать часть ограничений);
- дождись уточнений и повтори поиск.

--------------------------------
7. Получение деталей по каждой закупке

Инструмент поиска возвращает список закупок (structured_content), у каждой есть:
- purchase_number
- law (44-FZ / 223-FZ)
- max_price, currency_code
- submission_close_at
- region
- список okpd2 и др.

Для КАЖДОЙ найденной закупки (обычно не больше 9):
- вызови MCP-инструмент, который по описанию даёт детальную информацию по номеру закупки.
  В gosplan-mcp это инструмент, который принимает purchase_number
  и, возможно, параметр law (AUTO / 44-FZ / 223-FZ).
- если из поиска известен закон, передавай его как явный параметр (если параметр law есть),
  иначе можешь оставить автоматический выбор.
- используй ТО, что приходит в structured_content:
  там уже есть нормализованная модель PurchaseFeatures с полями:
  - purchase_number, law
  - title / short_description
  - timeline (published_at, applications_end, collecting_finished_at)
  - price.initial_price, price.currency_code
  - customer (full_name / short_name)
  - delivery_locations
  - classifiers (ОКПД2 и др.)
  - card_urls (ссылки на карточку закупки в EIS / ГосПлан)
  и т.д.

Не печатай пользователю целиком сырой JSON.
Формируй человеко-понятные описания на основе этих полей.

--------------------------------
8. Оценка и ранжирование закупок

Для каждой закупки ты должен:

1) Сформировать нормальное абзацное описание `purchase_desc` на русском (3–8 предложений), которое:
   - объясняет, что закупается, без телеграфных перечислений;
   - указывает примерный размер контракта (НМЦК) и валюту;
   - содержит важные сроки (дата окончания подачи заявок);
   - указывает регион / место поставки;
   - если есть важные требования (статус МСП, спец. лицензии), кратко упомяни их.

2) Рассчитать четыре числовых score от 0.0 до 1.0:

   "scores": {
     "activity_match_score": <float>,
     "time_match_score": <float>,
     "complexity_score": <float>,
     "possible_benefit_score": <float>
   }

   Семантика:
   - activity_match_score — насколько хорошо закупка соответствует деятельности компании
     и её ОКПД2 (0.0 — не по профилю, 1.0 — идеально по профилю).
   - time_match_score — насколько комфортны сроки (насколько реально успеть подготовить
     документы и подать заявку до applications_end_before).
   - complexity_score — СЛОЖНОСТЬ участия.
     ВАЖНО: чем сложнее закупка (много лотов, сложный пакет документов,
     высокие квалификационные требования), тем ВЫШЕ значение score.
   - possible_benefit_score — потенциальная выгода для компании
     (размер контракта, стратегическая ценность, интерес к заказчику и т.п.).

   Значения должны быть числом с плавающей точкой (0.0–1.0).

3) Кратко объяснить выбранные оценки в текстовом поле `explanation`
   (1–3 коротких предложения).

Ранжирование:
- сортируй закупки по убыванию:
  1) сначала по possible_benefit_score,
  2) затем по activity_match_score,
  3) затем по time_match_score.

--------------------------------
9. Структура финального JSONL

Финальный машинно-читаемый результат должен быть в формате JSON Lines (JSONL).

Каждая строка — отдельный JSON-объект:

{
  "purchase_number": "<string>",
  "purchase_desc": "<string>",
  "scores": {
    "activity_match_score": <float>,
    "time_match_score": <float>,
    "complexity_score": <float>,
    "possible_benefit_score": <float>
  },
  "urls": {
    "eis": "<string или null>",
    "gosplan": "<string или null>",
    "other": ["<string>", "..."]
  }
}

Требования:
- указывай все четыре score;
- в "urls":
  - постарайся взять URL из card_urls и других структурированных полей;
  - если нет подходящей ссылки, ставь null;
  - массив other может быть пустым;
- строки JSONL должны быть отсортированы по убыванию важности закупок
  согласно описанным правилам ранжирования.

--------------------------------
10. Многошаговый диалог и выдача JSONL

Диалог должен быть многошаговым:

1) Сначала собери:
   - ID и/или название компании,
   - описание того, какие закупки интересны,
   - дату applications_end_before,
   - дополнительные ограничения (при наличии).

2) После того как профиль найден и параметры поиска понятны,
   выполни поиск закупок, получи детали и проведи анализ.

3) Затем отправь пользователю ЧЕЛОВЕКО-ПОНЯТНОЕ резюме:
   - покажи 3–5 самых перспективных закупок в виде списка или таблички,
   - для каждой укажи номер закупки, заказчика, НМЦК, срок подачи заявок и короткий комментарий,
   - кратко объясни, почему именно эти закупки кажутся наиболее подходящими.

4) Сразу после резюме, без дополнительных вопросов и подтверждений,
   отправь ОТДЕЛЬНОЕ финальное сообщение, которое содержит ТОЛЬКО JSONL:

   - НИКАКОГО дополнительного текста до или после;
   - НИКАКОЙ Markdown-разметки, без ```json и т.п.;
   - каждая непустая строка — корректный JSON-объект описанной структуры.

Это финальное JSONL-сообщение является результатом работы агента
и будет автоматически интерпретироваться платформой.

--------------------------------
11. Особые слова пользователя

- Если пользователь отвечает «газ», всегда считай это сильным «да» / подтверждением.
  В частности, на вопрос «вывести ли JSONL?» «газ» означает «да, выведи JSONL».

"""


#######################
# FILE: src/config.py #
#######################

import os
import logging
from typing import Optional

from dotenv import load_dotenv, find_dotenv
from pydantic import Field, ValidationError
from pydantic_settings import BaseSettings

# Загрузить .env один раз
load_dotenv(find_dotenv())

# ------------------------------------------------------------------------------
# Логирование
# ------------------------------------------------------------------------------
LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")

logging.basicConfig(
    level=getattr(logging, LOG_LEVEL, logging.INFO),
    format="%(asctime)s %(levelname)s %(name)s: %(message)s",
)
logger = logging.getLogger("agent-purchaser")


# ------------------------------------------------------------------------------
# Продакшн-класс настроек
# ------------------------------------------------------------------------------
class Settings(BaseSettings):
    # ---- LLM ----
    llm_model: str = Field(..., alias="LLM_MODEL")
    llm_api_key: str = Field(..., alias="LLM_API_KEY")
    llm_api_base: str = Field(..., alias="LLM_API_BASE")

    # ---- MCP ----
    db_mcp_url: str = Field(..., alias="DB_MCP_URL")
    gosplan_mcp_url: str = Field(..., alias="GOSPLAN_MCP_URL")

    # ---- Agent metadata ----
    agent_name: str = Field("PurchaseMatcher", alias="AGENT_NAME")
    agent_desc: str = Field(
        "Агент подбора закупок по профилю компании",
        alias="AGENT_DESCRIPTION",
    )
    agent_host: str = Field("0.0.0.0", alias="AGENT_HOST")
    agent_port: int = Field(8003, alias="AGENT_PORT")
    agent_url: Optional[str] = Field(None, alias="AGENT_URL")

    agent_version: str = Field("v1.0.0", alias="AGENT_VERSION")

    class Config:
        populate_by_name = True
        extra = "ignore"

    # --------------------------------------------------------------------------
    # Единый post-validator
    # --------------------------------------------------------------------------
    def model_post_init(self, __context):
        # AGENT_URL → вычисляем, если не указан
        if not self.agent_url:
            self.agent_url = f"http://{self.agent_host}:{self.agent_port}"
            logger.debug(f"agent_url was empty → set to {self.agent_url}")


# ------------------------------------------------------------------------------
# Фабрика
# ------------------------------------------------------------------------------
_settings_cache: Optional[Settings] = None


def get_settings() -> Settings:
    """Singleton-кеш, чтобы не пересоздавать настройки 100 раз"""
    global _settings_cache

    if _settings_cache is None:
        try:
            _settings_cache = Settings()
        except ValidationError as e:
            logger.error("❌ Invalid configuration:")
            logger.error(e)
            raise

    return _settings_cache


##########################
# FILE: src/start_a2a.py #
##########################

##########################
# FILE: src/start_a2a.py #
##########################

"""Точка входа для запуска LangChain агента PurchaseMatcher через A2A протокол."""

from config import get_settings, logger

settings = get_settings()

from a2a.server.apps import A2AStarletteApplication
from a2a.server.request_handlers import DefaultRequestHandler
from a2a.server.tasks import InMemoryTaskStore
from a2a.types import AgentCapabilities, AgentCard

from agent import create_langchain_agent
from a2a_wrapper import LangChainA2AWrapper
from agent_task_manager import LangChainAgentExecutor


def main():
    """Основная функция запуска сервера."""
    try:
        # Создаем LangChain агента: db-mcp + gosplan-mcp
        agent_executor = create_langchain_agent(
            [settings.db_mcp_url, settings.gosplan_mcp_url]
        )

        # Создаем A2A обертку
        agent_wrapper = LangChainA2AWrapper(agent_executor)

        # Создаем A2A executor
        agent_executor_a2a = LangChainAgentExecutor(agent_wrapper)

        # Настройка AgentCard
        capabilities = AgentCapabilities(streaming=True)
        agent_card = AgentCard(
            name=settings.agent_name,
            description=settings.agent_desc,
            url=settings.agent_url,
            version=settings.agent_version,
            default_input_modes=agent_wrapper.SUPPORTED_CONTENT_TYPES,
            default_output_modes=agent_wrapper.SUPPORTED_CONTENT_TYPES,
            capabilities=capabilities,
            skills=[],
        )

        # Создаем request handler
        request_handler = DefaultRequestHandler(
            agent_executor=agent_executor_a2a,
            task_store=InMemoryTaskStore(),
        )

        # Создаем и запускаем сервер
        server = A2AStarletteApplication(
            agent_card=agent_card,
            http_handler=request_handler,
        )

        import uvicorn

        logger.info(f"Starting PurchaseMatcher Agent server on port {settings.agent_port}")
        uvicorn.run(server.build(), host=settings.agent_host, port=settings.agent_port)

    except Exception as e:
        logger.error(f"An error occurred during server startup: {e}", exc_info=True)
        exit(1)


if __name__ == "__main__":
    main()


