######################
# FILE: .env.example #
######################

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ MCP —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–∞
MCP_HOST=0.0.0.0
MCP_PORT=8000

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è —Å –ì–æ—Å–ü–ª–∞–Ω API
GOSPLAN_BASE_URL=https://v2test.gosplan.info
GOSPLAN_TIMEOUT=100,
GOSPLAN_PURCHASES_LIMIT=4

# –î—Ä—É–≥–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ MCP
LOG_LEVEL=INFO


#########################
# FILE: src/__init__.py #
#########################



#######################
# FILE: src/config.py #
#######################

"""–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¥–ª—è gosplan-mcp."""

from __future__ import annotations

import logging
import os
from functools import lru_cache

from dotenv import find_dotenv, load_dotenv
from pydantic import AnyHttpUrl, Field
from pydantic_settings import BaseSettings, SettingsConfigDict

load_dotenv(find_dotenv())

LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL, logging.INFO),
    format="%(asctime)s %(levelname)s %(name)s %(message)s",
)
logger = logging.getLogger("gosplan-mcp")


class Settings(BaseSettings):
    """–ù–∞—Å—Ç—Ä–æ–π–∫–∏ MCP —Å–µ—Ä–≤–µ—Ä–∞ –∏ –æ–±—Ä–∞—â–µ–Ω–∏–π –∫ –ì–æ—Å–ü–ª–∞–Ω API."""

    model_config = SettingsConfigDict(extra="ignore", env_prefix="", env_file=".env")

    server_port: int = Field(..., alias="MCP_PORT", ge=1, le=65535)
    server_host: str = Field(..., alias="MCP_HOST")

    gosplan_base_url: AnyHttpUrl = Field(
        "https://v2test.gosplan.info",
        alias="GOSPLAN_BASE_URL",
        description="–ë–∞–∑–æ–≤—ã–π URL API –ì–æ—Å–ü–ª–∞–Ω",
    )
    gosplan_timeout_seconds: float = Field(
        20.0,
        alias="GOSPLAN_TIMEOUT",
        description="–¢–∞–π–º–∞—É—Ç HTTP-–∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –ì–æ—Å–ü–ª–∞–Ω, —Å–µ–∫.",
        ge=1,
        le=120,
    )
    purchases_limit: int = Field(
        9,
        alias="GOSPLAN_PURCHASES_LIMIT",
        description="–û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –Ω–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–∫—É–ø–æ–∫ –∑–∞ –æ–¥–∏–Ω –≤—ã–∑–æ–≤",
        ge=1,
        le=50,
    )


@lru_cache
def get_settings() -> Settings:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –Ω–∞—Å—Ç—Ä–æ–µ–∫."""

    return Settings()


#############################
# FILE: src/mcp_instance.py #
#############################

"""–ï–¥–∏–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä FastMCP –¥–ª—è gosplan-mcp."""

from fastmcp import FastMCP

mcp = FastMCP("gosplan-mcp")


#######################
# FILE: src/server.py #
#######################

"""MCP —Å–µ—Ä–≤–µ—Ä –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –¥–∞–Ω–Ω—ã–º–∏ –ì–æ—Å–ü–ª–∞–Ω –ø–æ HTTP."""

from __future__ import annotations

import uvicorn
from starlette.middleware import Middleware
from starlette.middleware.cors import CORSMiddleware

from config import get_settings
from mcp_instance import mcp

settings = get_settings()

print("üîß –ó–∞–≥—Ä—É–∂–∞–µ–º –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã...")
try:
    from tools.gosplan_search import search_purchases
    print("‚úÖ search_purchases –∑–∞–≥—Ä—É–∂–µ–Ω")
except Exception as exc:  # pragma: no cover - –æ—Ç–ª–∞–¥–æ—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    print(f"‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ search_purchases: {exc}")
    import traceback

    traceback.print_exc()

try:
    from tools.gosplan_details import get_purchase_details
    print("‚úÖ get_purchase_details –∑–∞–≥—Ä—É–∂–µ–Ω")
except Exception as exc:  # pragma: no cover - –æ—Ç–ª–∞–¥–æ—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    print(f"‚ùå –û—à–∏–±–∫–∞ –∏–º–ø–æ—Ä—Ç–∞ get_purchase_details: {exc}")
    import traceback

    traceback.print_exc()

middleware = [
    Middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["GET", "POST", "DELETE", "OPTIONS"],
        allow_headers=[
            "mcp-protocol-version",
            "mcp-session-id",
            "Authorization",
            "Content-Type",
        ],
        expose_headers=["mcp-session-id"],
    )
]

app = mcp.http_app(middleware=middleware)


def main() -> None:
    """–ó–∞–ø—É—Å–∫–∞–µ—Ç MCP —Å–µ—Ä–≤–µ—Ä —Å HTTP —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç–æ–º –∏ CORS."""

    print("=" * 60)
    print("üåê –ó–ê–ü–£–°–ö MCP –°–ï–†–í–ï–†–ê (HTTP + CORS)")
    print("=" * 60)
    print(f"üöÄ MCP Server: http://{settings.server_host}:{settings.server_port}/mcp")
    print(f"üìä –ú–µ—Ç—Ä–∏–∫–∏:    http://{settings.server_host}:{settings.server_port}/metrics")
    print(f"üè• Health:     http://{settings.server_host}:{settings.server_port}/health")
    print("üîß –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ MCP Inspector (Connection Type: Direct)")
    print("=" * 60)
    print("‚è≥ –ó–∞–ø—É—Å–∫–∞–µ–º Uvicorn...")

    try:
        uvicorn.run(
            app,
            host=settings.server_host,
            port=settings.server_port,
        )
    except KeyboardInterrupt:  # pragma: no cover - –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ —á–µ—Ä–µ–∑ Ctrl+C
        print("\nüõë –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ (Ctrl+C)")
        print("üîÑ –í—ã–ø–æ–ª–Ω—è–µ–º graceful shutdown...")
        print("‚úÖ –°–µ—Ä–≤–µ—Ä –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
    except Exception as exc:  # pragma: no cover - –æ—Ç–ª–∞–¥–æ—á–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        print(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞: {exc}")
        import traceback

        traceback.print_exc()


if __name__ == "__main__":
    main()


###############################
# FILE: src/tools/__init__.py #
###############################



######################################
# FILE: src/tools/gosplan_details.py #
######################################

"""–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Ç–∞–ª–µ–π –∑–∞–∫—É–ø–∫–∏ –ø–æ –Ω–æ–º–µ—Ä—É."""

from __future__ import annotations

from typing import Literal

import httpx
from fastmcp import Context
from mcp.shared.exceptions import ErrorData, McpError
from mcp.types import TextContent
from pydantic import Field

from mcp_instance import mcp
from models import LawLiteral, PurchaseFeatures
from tools.utils import (
    ToolResult,
    build_purchase_features,
    create_http_client,
    format_api_error,
    format_purchase_details,
)

LAW_PATHS: dict[LawLiteral, str] = {
    "44-FZ": "fz44",
    "223-FZ": "fz223",
}


@mcp.tool(
    name="get_purchase_details",
    description=(
        "üìã –î–µ—Ç–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∑–∞–∫—É–ø–∫–µ –ø–æ –Ω–æ–º–µ—Ä—É –¥–ª—è 44-–§–ó –∏ 223-–§–ó"
    ),
)
async def get_purchase_details(
    ctx: Context,
    purchase_number: str = Field(..., description="–ù–æ–º–µ—Ä –∑–∞–∫—É–ø–∫–∏"),
    law: Literal["AUTO", LawLiteral] = Field(
        "AUTO", description="–Ø–≤–Ω–æ —É–∫–∞–∑–∞—Ç—å –∑–∞–∫–æ–Ω –∏–ª–∏ –≤—ã–±—Ä–∞—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏."
    ),
) -> ToolResult:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø–æ–¥—Ä–æ–±–Ω–æ—Å—Ç–∏ –∑–∞–∫—É–ø–∫–∏ –ø–æ –µ—ë –Ω–æ–º–µ—Ä—É."""

    await ctx.info(f"üìã –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª–∏ –∑–∞–∫—É–ø–∫–∏ {purchase_number}")
    await ctx.report_progress(progress=0, total=100)

    if not purchase_number:
        message = "–ü—É—Å—Ç–æ–π –Ω–æ–º–µ—Ä –∑–∞–∫—É–ø–∫–∏"
        await ctx.error(message)
        raise McpError(ErrorData(code=-32602, message=message))

    await ctx.report_progress(progress=20, total=100)

    laws_chain: list[LawLiteral]
    if law == "AUTO":
        laws_chain = ["44-FZ", "223-FZ"] if len(purchase_number) > 15 else ["223-FZ", "44-FZ"]
    else:
        laws_chain = [law]

    last_error: Exception | None = None
    purchase: PurchaseFeatures | None = None

    async with create_http_client() as client:
        for current_law in laws_chain:
            path = f"/{LAW_PATHS[current_law]}/purchases/{purchase_number}"
            try:
                response = await client.get(path)
                if response.status_code == 404:
                    continue
                
                response.raise_for_status()
                purchase = build_purchase_features(response.json(), current_law)
                break
            
            except httpx.HTTPStatusError as exc:
                last_error = exc
                if exc.response is not None and exc.response.status_code == 404:
                    continue

                error_message = format_api_error(
                    exc.response.text if exc.response else "",
                    exc.response.status_code if exc.response else 0,
                )
                await ctx.error(f"‚ùå HTTP –æ—à–∏–±–∫–∞: {error_message}")
                
                raise McpError(
                    ErrorData(
                        code=-32603,
                        message=(
                            "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –∑–∞–∫—É–ø–∫–∏.\n\n" f"{error_message}"
                        ),
                    )
                ) from exc
                
            except httpx.RequestError as exc:
                last_error = exc
                await ctx.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞: {exc}")
                
                raise McpError(
                    ErrorData(
                        code=-32603, message="–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å –∫ API"
                    ),
                ) from exc

    if purchase is None:
        await ctx.error("‚ùå –ó–∞–∫—É–ø–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –Ω–∏ –ø–æ 44-–§–ó, –Ω–∏ –ø–æ 223-–§–ó")
        
        raise McpError(
            ErrorData(
                code=-32602,
                message=(
                    "–ó–∞–∫—É–ø–∫–∞ —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º –Ω–æ–º–µ—Ä–æ–º –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –ì–æ—Å–ü–ª–∞–Ω (44-–§–ó/223-–§–ó)."
                ),
            )
        ) from last_error

    await ctx.report_progress(progress=80, total=100)
    formatted_text = format_purchase_details(purchase)

    await ctx.report_progress(progress=100, total=100)
    
    return ToolResult(
        content=[TextContent(type="text", text=formatted_text)],
        structured_content=purchase.model_dump(),
        meta={
            "purchase_number": purchase.purchase_number,
            "law": purchase.law,
        },
    )


#####################################
# FILE: src/tools/gosplan_search.py #
#####################################

"""–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –ø–æ–∏—Å–∫–∞ –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–∞–∫—É–ø–æ–∫ –ø–æ 44-–§–ó –∏ 223-–§–ó."""

from __future__ import annotations

from datetime import datetime
from typing import Iterable, List

import httpx
from fastmcp import Context
from mcp.shared.exceptions import ErrorData, McpError
from mcp.types import TextContent
from pydantic import Field, ValidationError

from config import get_settings
from mcp_instance import mcp
from models import LawLiteral, PurchaseListItem, SearchPurchasesParams
from tools.utils import (
    ToolResult,
    create_http_client,
    filter_and_slice_results,
    format_api_error,
    format_purchase_list,
    parse_datetime,
)


LAW_PATHS: dict[LawLiteral, str] = {
    "44-FZ": "fz44",
    "223-FZ": "fz223",
}


def _prepare_query(params: SearchPurchasesParams, limit: int) -> dict:
    query: dict[str, str | int | list[str] | list[int]] = {
        "limit": limit,
        "currency_code": params.currency_code,
        "sort": params.sort,
        "stage": params.stage,
    }

    if params.classifiers:
        query["classifier"] = params.classifiers
    if params.region_codes:
        query["region"] = params.region_codes
    if params.collecting_finished_after:
        query["collecting_finished_after"] = (
            params.collecting_finished_after.isoformat()
        )
    if params.collecting_finished_before:
        query["collecting_finished_before"] = (
            params.collecting_finished_before.isoformat()
        )

    return query


def _sort_purchases(items: Iterable[PurchaseListItem]) -> List[PurchaseListItem]:
    return sorted(
        items,
        key=lambda item: item.published_at or datetime.min,
        reverse=True,
    )


@mcp.tool(
    name="search_purchases",
    description=(
        "üîç –ü–æ–∏—Å–∫ –∑–∞–∫—É–ø–æ–∫ –ø–æ –û–ö–ü–î2, —Ä–µ–≥–∏–æ–Ω–∞–º –∏ –¥–µ–¥–ª–∞–π–Ω—É –ø–æ–¥–∞—á–∏ –∑–∞—è–≤–æ–∫."
        " –†–∞–±–æ—Ç–∞–µ—Ç –ø–æ 44-–§–ó –∏ 223-–§–ó, —Å–æ—Ä—Ç–∏—Ä—É–µ—Ç –ø–æ –¥–∞—Ç–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è."
    ),
)
async def search_purchases(
    ctx: Context,
    classifiers: List[str] = Field(
        default_factory=list,
        description="–ö–æ–¥—ã –∫–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤ (—Ç–æ–ª—å–∫–æ –û–ö–ü–î2), –º–æ–∂–Ω–æ –Ω–µ—Å–∫–æ–ª—å–∫–æ –∑–Ω–∞—á–µ–Ω–∏–π.",
    ),
    region_codes: List[int] = Field(
        default_factory=list, description="–ö–æ–¥—ã —Ä–µ–≥–∏–æ–Ω–æ–≤, –ø—É—Å—Ç–æ ‚Äî –≤—Å–µ —Ä–µ–≥–∏–æ–Ω—ã."
    ),
    collecting_finished_after: str | None = Field(
        None,
        description="ISO –¥–∞—Ç–∞/–≤—Ä–µ–º—è: –æ–∫–æ–Ω—á–∞–Ω–∏–µ –ø–æ–¥–∞—á–∏ –∑–∞—è–≤–æ–∫ –ø–æ–∑–∂–µ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –º–æ–º–µ–Ω—Ç–∞.",
    ),
    collecting_finished_before: str | None = Field(
        None,
        description="ISO –¥–∞—Ç–∞/–≤—Ä–µ–º—è: –æ–∫–æ–Ω—á–∞–Ω–∏–µ –ø–æ–¥–∞—á–∏ –∑–∞—è–≤–æ–∫ —Ä–∞–Ω—å—à–µ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –º–æ–º–µ–Ω—Ç–∞.",
    ),
) -> ToolResult:
    """–ü–æ–∏—Å–∫ –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–∞–∫—É–ø–æ–∫ –ø–æ –≤—Ö–æ–¥–Ω—ã–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º."""

    await ctx.info("üîç –ù–∞—á–∏–Ω–∞–µ–º –ø–æ–∏—Å–∫ –≥–æ—Å—É–¥–∞—Ä—Å—Ç–≤–µ–Ω–Ω—ã—Ö –∑–∞–∫—É–ø–æ–∫")
    await ctx.report_progress(progress=0, total=100)

    settings = get_settings()
    try:
        finished_after_dt = parse_datetime(collecting_finished_after)
        finished_before_dt = parse_datetime(collecting_finished_before)
        params = SearchPurchasesParams(
            classifiers=classifiers,
            region_codes=region_codes,
            collecting_finished_after=finished_after_dt,
            collecting_finished_before=finished_before_dt,
            limit=settings.purchases_limit * 2,
        )
        
    except ValidationError as exc:
        await ctx.error(f"‚ùå –ù–µ–≤–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã: {exc}")
        raise McpError(
            ErrorData(code=-32602, message=f"–ù–µ–≤–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã: {exc}")
        ) from exc

    await ctx.report_progress(progress=15, total=100)

    laws_to_query: list[LawLiteral] = ["44-FZ", "223-FZ"]
    collected: list[PurchaseListItem] = []
    per_law_limit = settings.purchases_limit

    async with create_http_client() as client:
        for current_law in laws_to_query:
            query_params = _prepare_query(params, per_law_limit)
            path = f"/{LAW_PATHS[current_law]}/purchases"

            try:
                response = await client.get(path, params=query_params)
                response.raise_for_status()
            except httpx.HTTPStatusError as exc:
                error_message = format_api_error(
                    exc.response.text if exc.response else "",
                    exc.response.status_code if exc.response else 0,
                )
                await ctx.error(f"‚ùå HTTP –æ—à–∏–±–∫–∞: {error_message}")
                raise McpError(
                    ErrorData(
                        code=-32603,
                        message=f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∑–∞–∫—É–ø–æ–∫.\n\n{error_message}",
                    )
                ) from exc
                
            except httpx.RequestError as exc:
                await ctx.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞: {exc}")
                raise McpError(
                    ErrorData(
                        code=-32603,
                        message="–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å –∫ API",
                    )
                ) from exc

            batch = [
                PurchaseListItem(law=current_law, **item)
                for item in response.json()
            ]
            collected.extend(batch)

    await ctx.report_progress(progress=70, total=100)

    filtered = filter_and_slice_results(
        _sort_purchases(collected),
        params,
        limit=params.limit,
    )

    await ctx.report_progress(progress=90, total=100)
    formatted_text = format_purchase_list(filtered)

    await ctx.report_progress(progress=100, total=100)

    return ToolResult(
        content=[TextContent(type="text", text=formatted_text)],
        structured_content=[item.model_dump() for item in filtered],
        meta={"count": len(filtered)},
    )


############################
# FILE: src/tools/utils.py #
############################

"""–£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ì–æ—Å–ü–ª–∞–Ω API –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–æ–≤."""

from __future__ import annotations

import json
import os
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Iterable, List, Optional

import httpx
from mcp.shared.exceptions import ErrorData, McpError
from mcp.types import TextContent

from config import get_settings
from models import (
    AttachmentInfo,
    ClassifierCode,
    CustomerInfo,
    LawLiteral,
    LocationInfo,
    PlatformInfo,
    PreferenceInfo,
    PurchaseFeatures,
    PurchaseListItem,
    PurchaseObjectItem,
    RequirementInfo,
    SearchPurchasesParams,
    TimelineInfo,
    PriceInfo,
)


@dataclass
class ToolResult:
    """–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –æ–±–µ—Ä—Ç–∫–∞ –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ MCP –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞."""

    content: list[TextContent]
    structured_content: dict[str, Any] | list[dict[str, Any]]
    meta: dict[str, Any]


def check_required_env_vars(required_vars: list[str]) -> None:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –∑–∞–ø–æ–ª–Ω–µ–Ω—ã."""

    missing = [var for var in required_vars if not os.getenv(var)]
    if missing:
        raise McpError(
            ErrorData(
                code=-32602,
                message=(
                    "–ù–µ –∑–∞–¥–∞–Ω—ã –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è: "
                    + ", ".join(sorted(missing))
                ),
            )
        )


def create_http_client() -> httpx.AsyncClient:
    """–°–æ–∑–¥–∞–µ—Ç –Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π HTTP –∫–ª–∏–µ–Ω—Ç –¥–ª—è –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ –ì–æ—Å–ü–ª–∞–Ω."""

    settings = get_settings()
    return httpx.AsyncClient(
        base_url=str(settings.gosplan_base_url),
        timeout=settings.gosplan_timeout_seconds,
        headers={"User-Agent": "gosplan-mcp/2.0"},
    )


def parse_datetime(value: Any) -> Optional[datetime]:
    """–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ ISO-—Å—Ç—Ä–æ–∫ –¥–∞—Ç—ã/–≤—Ä–µ–º–µ–Ω–∏."""

    if not value:
        return None
    if isinstance(value, datetime):
        return value
    try:
        return datetime.fromisoformat(str(value).replace("Z", "+00:00"))
    except (TypeError, ValueError):
        return None


def format_api_error(api_error: str, code: int) -> str:
    """–í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —É–¥–æ–±–æ—á–∏—Ç–∞–µ–º–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –æ—à–∏–±–∫–∏ API."""

    try:
        parsed = json.loads(api_error) if api_error else {}
    except json.JSONDecodeError:
        parsed = api_error

    if code == 404:
        return "–ó–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"

    if code == 422:
        details: list[str] = []

        if isinstance(parsed, dict) and "detail" in parsed:
            detail = parsed["detail"]
            if isinstance(detail, list):
                for item in detail:
                    if isinstance(item, dict):
                        location = ".".join(str(part) for part in item.get("loc", []))
                        message = item.get("msg", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞")
                        if location:
                            details.append(f"{location}: {message}")
                        else:
                            details.append(message)
                    else:
                        details.append(str(item))
            else:
                details.append(str(detail))
        elif parsed:
            details.append(str(parsed))
        else:
            details.append("–û—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏")

        return "–û—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏:\n  - " + "\n  - ".join(details)

    if isinstance(parsed, dict) and "detail" in parsed:
        return str(parsed["detail"])

    if isinstance(parsed, dict):
        return json.dumps(parsed, ensure_ascii=False)

    return str(api_error) if api_error else "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞"


def format_purchase_summary(purchase: PurchaseListItem) -> str:
    """–ö—Ä–∞—Ç–∫–æ–µ —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∑–∞–∫—É–ø–∫–∏."""

    stage_map = {
        1: "–ø–æ–¥–∞—á–∞ –∑–∞—è–≤–æ–∫",
        2: "—Ä–∞–±–æ—Ç–∞ –∫–æ–º–∏—Å—Å–∏–∏",
        3: "–∑–∞–∫—É–ø–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞",
        4: "–∑–∞–∫—É–ø–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞",
    }

    close_at_str = (
        purchase.submission_close_at.isoformat()
        if purchase.submission_close_at
        else "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
    )
    max_price_str = (
        f"{purchase.max_price:,.2f}".replace(",", " ") if purchase.max_price else "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
    )

    return (
        f"–ù–æ–º–µ—Ä: {purchase.purchase_number}\n"
        f"–ó–∞–∫–æ–Ω: {purchase.law}\n"
        f"–û–ø–∏—Å–∞–Ω–∏–µ: {purchase.object_info or '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}\n"
        f"–¶–µ–Ω–∞: {max_price_str} {purchase.currency_code}\n"
        f"–û–∫–æ–Ω—á–∞–Ω–∏–µ –ø—Ä–∏–µ–º–∞: {close_at_str}\n"
        f"–°—Ç–∞–¥–∏—è: {stage_map.get(purchase.stage, '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ')}\n"
        f"–†–µ–≥–∏–æ–Ω: {purchase.region or '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}\n"
        f"–û–ö–ü–î2: {', '.join(purchase.okpd2) if purchase.okpd2 else '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}"
    )


def format_purchase_list(purchases: List[PurchaseListItem]) -> str:
    """–§–æ—Ä–º–∏—Ä—É–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤—ã–π —Å–ø–∏—Å–æ–∫ –∑–∞–∫—É–ø–æ–∫ –¥–ª—è –æ—Ç–≤–µ—Ç–∞ LLM."""

    header = f"–ü–æ–∫–∞–∑–∞–Ω–æ: {len(purchases)}\n\n" if purchases else "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã"
    formatted_items = []

    for idx, purchase in enumerate(purchases, start=1):
        formatted_items.append(f"{idx}.\n{format_purchase_summary(purchase)}")

    return header + ("\n\n".join(formatted_items) if formatted_items else "")


def format_purchase_details(purchase: PurchaseFeatures) -> str:
    """–ü–æ–¥—Ä–æ–±–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∑–∞–∫—É–ø–∫–∏ —Å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è–º–∏ –∏ –º–µ—Å—Ç–∞–º–∏ –ø–æ—Å—Ç–∞–≤–∫–∏."""

    lines = [
        f"–ù–æ–º–µ—Ä –∑–∞–∫—É–ø–∫–∏: {purchase.purchase_number} ({purchase.law})",
        f"–ù–∞–∑–≤–∞–Ω–∏–µ: {purchase.title or purchase.short_description or '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}",
        f"–ó–∞–∫–∞–∑—á–∏–∫: {purchase.customer.full_name or purchase.customer.short_name or '–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö'}",
        f"–ù–ú–¶–ö: {purchase.price.initial_price:,.2f} {purchase.price.currency_code}".replace(",", " "),
    ]

    if purchase.timeline.applications_end:
        lines.append(
            f"–û–∫–æ–Ω—á–∞–Ω–∏–µ –ø–æ–¥–∞—á–∏ –∑–∞—è–≤–æ–∫: {purchase.timeline.applications_end.isoformat()}"
        )
    if purchase.timeline.published_at:
        lines.append(f"–û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ: {purchase.timeline.published_at.isoformat()}")

    if purchase.classifiers:
        classifier_text = ", ".join(f"{c.code} ({c.system})" for c in purchase.classifiers)
        lines.append(f"–ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã: {classifier_text}")

    if purchase.delivery_locations:
        lines.append("–ú–µ—Å—Ç–∞ –ø–æ—Å—Ç–∞–≤–∫–∏:")
        for loc in purchase.delivery_locations:
            parts = [loc.region_name or loc.region_code, loc.locality_name, loc.raw_address]
            address = ", ".join(filter(None, parts)) or "–Ω–µ—Ç –¥–∞–Ω–Ω—ã—Ö"
            lines.append(f"  - {address}")

    if purchase.attachments:
        lines.append(f"–î–æ–∫—É–º–µ–Ω—Ç—ã ({len(purchase.attachments)}):")
        for attachment in purchase.attachments:
            lines.append(
                f"  - {attachment.file_name} ({attachment.kind_name or '–¥–æ–∫—É–º–µ–Ω—Ç'}) ‚Äî {attachment.url}"
            )

    if purchase.objects:
        lines.append("–û–±—ä–µ–∫—Ç—ã –∑–∞–∫—É–ø–∫–∏:")
        for obj in purchase.objects:
            codes = ", ".join(c.code for c in obj.classifiers) if obj.classifiers else ""
            lines.append(
                f"  - {obj.name or '–ø–æ–∑–∏—Ü–∏—è'}" + (f" [{codes}]" if codes else "")
            )

    if purchase.plan_numbers:
        lines.append(f"–ü–ª–∞–Ω—ã: {', '.join(purchase.plan_numbers)}")

    return "\n".join(lines)


def extract_customer_info(doc: dict[str, Any]) -> CustomerInfo:
    """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–∫–∞–∑—á–∏–∫–µ –∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞ –∏—Å—Ç–æ—á–Ω–∏–∫–∞."""

    main_info = (
        doc.get("customer", {}).get("mainInfo")
        or doc.get("purchaseResponsibleInfo", {}).get("responsibleOrgInfo", {})
    )
    return CustomerInfo(
        inn=main_info.get("inn") if isinstance(main_info, dict) else None,
        kpp=main_info.get("kpp") if isinstance(main_info, dict) else None,
        ogrn=main_info.get("ogrn") if isinstance(main_info, dict) else None,
        full_name=main_info.get("fullName") if isinstance(main_info, dict) else None,
        short_name=main_info.get("shortName") if isinstance(main_info, dict) else None,
        customer_reg_num=main_info.get("iko") if isinstance(main_info, dict) else None,
        region_name=main_info.get("regionName") if isinstance(main_info, dict) else None,
        legal_address=main_info.get("legalAddress") if isinstance(main_info, dict) else None,
        postal_address=main_info.get("postalAddress") if isinstance(main_info, dict) else None,
        email=main_info.get("email") if isinstance(main_info, dict) else None,
        phone=main_info.get("phone") if isinstance(main_info, dict) else None,
    )


def extract_platform_info(doc: dict[str, Any], law: LawLiteral) -> PlatformInfo:
    placing_way = doc.get("commonInfo", {}).get("placingWay") if isinstance(doc, dict) else None
    etp = doc.get("commonInfo", {}).get("ETP") if isinstance(doc, dict) else None

    return PlatformInfo(
        law=law,
        placing_way_code=placing_way.get("code") if isinstance(placing_way, dict) else None,
        placing_way_name=placing_way.get("name") if isinstance(placing_way, dict) else None,
        etp_code=etp.get("code") if isinstance(etp, dict) else None,
        etp_name=etp.get("name") if isinstance(etp, dict) else None,
        etp_url=etp.get("url") if isinstance(etp, dict) else None,
        is_electronic=bool(etp) if etp else None,
    )


def extract_delivery_locations(raw: dict[str, Any]) -> list[LocationInfo]:
    locations: list[LocationInfo] = []
    for place in raw.get("delivery_places", []) or []:
        locations.append(LocationInfo(raw_address=str(place)))

    for kladr in raw.get("delivery_places_kladr", []) or []:
        locations.append(LocationInfo(kladr_or_okato=str(kladr)))

    return locations


def extract_classifiers(okpd2_list: Iterable[str]) -> list[ClassifierCode]:
    return [ClassifierCode(system="OKPD2", code=code) for code in okpd2_list]


def extract_attachments(doc: dict[str, Any]) -> list[AttachmentInfo]:
    attachments_block = doc.get("attachmentsInfo", {}).get("attachmentInfo", []) if isinstance(doc, dict) else []
    attachments: list[AttachmentInfo] = []

    for attachment in attachments_block or []:
        if not isinstance(attachment, dict):
            continue
        size_str = attachment.get("fileSize")
        attachments.append(
            AttachmentInfo(
                uid=attachment.get("publishedContentId"),
                kind_code=(attachment.get("docKindInfo") or {}).get("code"),
                kind_name=(attachment.get("docKindInfo") or {}).get("name"),
                file_name=attachment.get("fileName", "–î–æ–∫—É–º–µ–Ω—Ç"),
                description=attachment.get("docDescription"),
                url=attachment.get("url"),
                size_bytes=int(size_str) if size_str and str(size_str).isdigit() else None,
                doc_date=parse_datetime(attachment.get("docDate")),
            )
        )

    return attachments


def extract_objects(doc: dict[str, Any]) -> list[PurchaseObjectItem]:
    purchase_objects = (
        doc.get("notificationInfo", {})
        .get("purchaseObjectsInfo", {})
        .get("purchaseObject")
    )
    objects: list[PurchaseObjectItem] = []

    if isinstance(purchase_objects, list):
        iterable = purchase_objects
    elif purchase_objects:
        iterable = [purchase_objects]
    else:
        iterable = []

    for obj in iterable:
        if not isinstance(obj, dict):
            continue
        classifiers = []
        if isinstance(obj.get("KTRU"), dict):
            ktru = obj["KTRU"]
            classifiers.append(
                ClassifierCode(system="KTRU", code=ktru.get("code", ""), name=ktru.get("name"))
            )
            okpd = ktru.get("OKPD2", {}) if isinstance(ktru, dict) else {}
            if isinstance(okpd, dict) and okpd.get("OKPDCode"):
                classifiers.append(
                    ClassifierCode(
                        system="OKPD2", code=okpd.get("OKPDCode", ""), name=okpd.get("OKPDName")
                    )
                )

        objects.append(
            PurchaseObjectItem(
                name=obj.get("name"),
                classifiers=classifiers,
                ktru_code=(obj.get("KTRU") or {}).get("code") if isinstance(obj.get("KTRU"), dict) else None,
                quantity=float(obj.get("quantity", {}).get("value"))
                if isinstance(obj.get("quantity"), dict) and obj.get("quantity", {}).get("value")
                else None,
                quantity_unit_code=(obj.get("OKEI") or {}).get("code") if isinstance(obj.get("OKEI"), dict) else None,
                quantity_unit_name=(obj.get("OKEI") or {}).get("name") if isinstance(obj.get("OKEI"), dict) else None,
                price_per_unit=float(obj.get("price")) if obj.get("price") else None,
                total_sum=float(obj.get("sum")) if obj.get("sum") else None,
                object_type=obj.get("type"),
            )
        )

    return objects


def build_purchase_features(raw: dict[str, Any], law: LawLiteral) -> PurchaseFeatures:
    """–°–æ–±–∏—Ä–∞–µ—Ç –Ω–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—É—é –º–æ–¥–µ–ª—å PurchaseFeatures –∏–∑ –æ—Ç–≤–µ—Ç–∞ API."""

    doc = (raw.get("docs") or [{}])[0].get("source", {}) if raw.get("docs") else {}

    classifiers = extract_classifiers(raw.get("okpd2") or [])
    objects = extract_objects(doc)
    attachments = extract_attachments(doc)
    locations = extract_delivery_locations(raw)

    price = PriceInfo(
        currency_code=raw.get("currency_code", "RUB"),
        initial_price=float(raw.get("max_price") or 0.0),
        contract_guarantee_amount=raw.get("contract_guarantee_amount"),
        contract_guarantee_part=raw.get("contract_guarantee_part"),
    )

    timeline = TimelineInfo(
        published_at=parse_datetime(raw.get("published_at")),
        updated_at=parse_datetime(raw.get("updated_at")),
        applications_end=parse_datetime(raw.get("submission_close_at")),
        collecting_finished_at=parse_datetime(raw.get("collecting_finished_at")),
    )

    requirements_block = (
        doc.get("notificationInfo", {})
        .get("requirementsInfo", {})
        .get("requirement")
    )
    if isinstance(requirements_block, dict):
        requirements_iter = [requirements_block]
    elif isinstance(requirements_block, list):
        requirements_iter = requirements_block
    else:
        requirements_iter = []

    preferences_block = (
        doc.get("notificationInfo", {}).get("preferensesInfo", {}).get("preferense")
    )
    if isinstance(preferences_block, dict):
        preferences_iter = [preferences_block]
    elif isinstance(preferences_block, list):
        preferences_iter = preferences_block
    else:
        preferences_iter = []

    return PurchaseFeatures(
        source_system="GOSPLAN",
        law=law,
        purchase_number=raw.get("purchase_number", ""),
        lot_number=None,
        lot_internal_id=None,
        ikz=(raw.get("ikzs") or [None])[0] if raw.get("ikzs") else None,
        plan_numbers=raw.get("plan_numbers") or [],
        plan_position_numbers=raw.get("position_numbers") or [],
        title=raw.get("object_info"),
        short_description=raw.get("object_info"),
        extended_description=None,
        stage=raw.get("stage"),
        status=raw.get("purchase_type"),
        is_cancelled=None,
        customer=extract_customer_info(doc),
        platform=extract_platform_info(doc, law),
        delivery_locations=locations,
        timeline=timeline,
        price=price,
        classifiers=classifiers,
        objects=objects,
        requirements=[
            RequirementInfo(name=req.get("name", "–¢—Ä–µ–±–æ–≤–∞–Ω–∏–µ"), code=req.get("code"))
            for req in requirements_iter
            if isinstance(req, dict)
        ],
        preferences=[
            PreferenceInfo(name=pref.get("name", "–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ"), code=pref.get("code"))
            for pref in preferences_iter
            if isinstance(pref, dict)
        ],
        sme_only=None,
        sme_preference=None,
        card_urls=[
            url
            for url in [raw.get("card_url"), (doc.get("commonInfo", {}) or {}).get("href")]
            if url
        ],
        attachments=attachments,
        extra={"raw": raw},
    )


def filter_and_slice_results(
    purchases: List[PurchaseListItem],
    params: SearchPurchasesParams,
    limit: int,
) -> List[PurchaseListItem]:
    """–ü—Ä–∏–º–µ–Ω—è–µ—Ç –∫–ª–∏–µ–Ω—Ç—Å–∫–∏–µ —Ñ–∏–ª—å—Ç—Ä—ã –∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É."""

    filtered: list[PurchaseListItem] = []
    for item in purchases:
        if params.region_codes and item.region is not None and item.region not in params.region_codes:
            continue
        if params.collecting_finished_after and item.submission_close_at:
            if item.submission_close_at <= params.collecting_finished_after:
                continue
        if params.collecting_finished_before and item.submission_close_at:
            if item.submission_close_at >= params.collecting_finished_before:
                continue
        filtered.append(item)
        if len(filtered) >= limit:
            break

    return filtered


###############################
# FILE: src/utils/__init__.py #
###############################

from .settings import ROOT_DIR, Settings, settings

__all__ = (
    "ROOT_DIR",
    "Settings",
    "settings",

)


###############################
# FILE: src/utils/settings.py #
###############################

from functools import lru_cache
from pathlib import Path

from dynaconf import Dynaconf  # type: ignore[import-untyped]
from pydantic import (
    BaseModel,
    model_validator,
)
from pydantic_settings import BaseSettings

__all__ = (
    "ROOT_DIR",
    "App",
    "Settings",
    "load_settings",
    "settings",
)

ROOT_DIR = Path(__file__).resolve().parent.parent.parent


class App(BaseModel):
    """Application configuration."""

    title: str
    version: str
    root_path: str
    port: int
    host: str
    opentelemetry_available: bool
    otel_endpoint: str
    otel_service_name: str

    @staticmethod
    def __parse_version_from_pyproject_toml() -> str:
        """Parse version from pyproject.toml file."""
        try:
            with open("pyproject.toml") as f:
                for line in f:
                    if line.startswith("version ="):
                        return line.split("=")[1].strip().strip('"')
        except FileNotFoundError:
            return "0.0.0"

        return "0.0.0"

    @model_validator(mode="after")
    def set_version_from_pyproject(self) -> "App":
        """Post-initialization to set default values."""
        temp = self.version
        parsed_version = self.__parse_version_from_pyproject_toml()

        if parsed_version != "0.0.0":
            self.version = parsed_version
        elif self.version == "0.0.0":
            self.version = temp

        return self


class Settings(BaseSettings):
    """Main configuration class."""

    app: App

    # skip extra validation for Dynaconf compatibility
    model_config = {
        "extra": "allow",  # Allow extra fields for Dynaconf compatibility
    }


@lru_cache(maxsize=1)
def load_settings(settings_dir: str | Path | None = None) -> Settings:
    """Load configuration from YAML files using Dynaconf.

    Args:
        settings_dir: Directory containing settings.yml and secrets.yml files.
            Default is the project root directory.

    Returns:
        Settings: Config Pydantic model instance with all settings.
    """
    if settings_dir is None:
        settings_dir = ROOT_DIR

    settings_path = (
        Path(settings_dir) if isinstance(settings_dir, str) else settings_dir
    )

    secrets_file = settings_path / ".secrets.yml"

    # Check if secrets file exists
    if not secrets_file.exists():
        raise FileNotFoundError(f"Settings file not found: {secrets_file}")

    # Prepare list of configuration files
    config_files = [str(secrets_file)]

    # Load configuration using Dynaconf
    dynaconf_settings = Dynaconf(
        settings_files=config_files,
        envvar_prefix="MCP_",
        load_dotenv=True,
        merge_enabled=True,
    )

    # Convert Dynaconf settings to a regular dictionary
    config_data = {k.lower(): v for k, v in dynaconf_settings.to_dict().items()}

    # Create Settings instance directly from config data
    return Settings.model_validate(config_data)


settings = load_settings()


