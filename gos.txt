######################
# FILE: .env.example #
######################

# ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ MCP Ñ‚Ñ€Ð°Ð½ÑÐ¿Ð¾Ñ€Ñ‚Ð°
MCP_HOST=0.0.0.0
MCP_PORT=8000

# Ð”Ñ€ÑƒÐ³Ð¸Ðµ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ MCP
LOG_LEVEL=INFO


####################
# FILE: Dockerfile #
####################

# syntax=docker/dockerfile:1-labs
FROM python:3.13-alpine AS base

RUN apk add --no-cache \
    poetry

COPY pyproject.toml poetry.lock* /build/


# =============================================================================
# DEV-BUILDER STAGE (Development)
# =============================================================================
FROM base AS dev-builder
WORKDIR /build
# Configure Poetry for dev build
RUN poetry config virtualenvs.create true \
    && poetry config virtualenvs.in-project true

# Install all dependencies with caching
RUN --mount=type=cache,target=/root/.cache/pip \
    --mount=type=cache,target=/root/.cache/poetry \
    poetry install --all-groups --no-root

RUN ls -la /build/
RUN find /build -name ".venv" -type d

# =============================================================================
# DEVELOPMENT STAGE
# =============================================================================
FROM python:3.13-alpine AS development

# Create dev user
RUN addgroup -g 1000 devuser && \
    adduser -D -u 1000 -G devuser -s /bin/sh -h /app devuser

# Set working directory
WORKDIR /app

# Copy virtual environment from dev-builder
COPY --from=dev-builder --chown=devuser:devuser /build/.venv /app/.venv

# Switch to unprivileged user
USER devuser

# Copy application source code
COPY --chown=devuser:devuser src/ /app/src

# Configure environment variables
ENV PATH="/app/.venv/bin:$PATH" \
    PYTHONPATH="/app"

# Create log directories
RUN mkdir -p /app/logs && \
    touch /app/logs/access.log && \
    touch /app/logs/error.log

# =============================================================================
# BUILDER STAGE (Production)
# =============================================================================
FROM base AS builder
WORKDIR /build
# Configure Poetry for production build
RUN poetry config virtualenvs.in-project true
# Install only production dependencies
RUN poetry install --only=main --no-root

# =============================================================================
# PRODUCTION STAGE
# =============================================================================
FROM python:3.13-alpine AS production

# Create production user
RUN addgroup -g 16458 produser && \
    adduser -D -u 16458 -G produser -s /bin/sh -h /app produser

# Set working directory
WORKDIR /app

# Copy virtual environment from builder
COPY --from=builder --chown=produser:produser /build/.venv /app/.venv

# Copy application source code
COPY --chown=produser:produser src/ /app/src
COPY --chown=produser:produser --chmod=600 .secrets.yml /app/.secrets.yml

# Switch to unprivileged user
USER produser

# Configure environment variables
ENV PATH="/app/.venv/bin:$PATH" \
    PYTHONPATH="/app"

# Create log directories
RUN mkdir -p /app/logs && \
    touch /app/logs/access.log && \
    touch /app/logs/error.log





########################
# FILE: pyproject.toml #
########################

[project]
name = "MCP_server"
version = "0.1.0"
description = ""
authors = [
    { name = "StolovAR", email = "andrey.stolov.04@gmail.com" }
]
readme = "README.md"
requires-python = ">=3.13,<3.14"

[tool.poetry]
package-mode = false

[tool.poetry.dependencies]
python = ">=3.13,<3.14"
orjson = "^3.10.18"
loguru = "^0.7.3"
pydantic = "^2.11.7"
pydantic-settings = "^2.10.1"
dynaconf = { extras = ["release", "yaml"], version = "^3.2.11" }
fastmcp = "^2.13.3"
prometheus-client = "^0.23.1"
opentelemetry-api = "^1.39.0"
opentelemetry-sdk = "^1.39.0"
opentelemetry-exporter-otlp-proto-http = "^1.39.0"

[tool.poetry.group.dev.dependencies]
ruff = ">=0.14.4"
mypy = ">=1.18.2"

[build-system]
requires = ["poetry-core>=2.0.0,<3.0.0"]
build-backend = "poetry.core.masonry.api"

[tool.mypy]
python_version = "3.13"
platform = "unix"
explicit_package_bases = true
warn_return_any = true
warn_unused_configs = true
warn_no_return = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_unreachable = true
strict = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
strict_optional = true
strict_equality = true
implicit_reexport = false
exclude = '''(?x)(
    \.eggs
    | \.git
    | \.hg
    | \.mypy_cache
    | \.tox
    | \.venv
    | _build
    | buck-out
    | build
    | dist
    | __pypackages__
    | \.pytest_cache
    | \.ruff_cache
    | \.direnv
)'''

[tool.ruff]
target-version = "py313"
exclude = [
    ".bzr",
    ".direnv",
    ".eggs",
    ".git",
    ".git-rewrite",
    ".hg",
    ".ipynb_checkpoints",
    ".mypy_cache",
    ".nox",
    ".pants.d",
    ".pyenv",
    ".pytest_cache",
    ".pytype",
    ".ruff_cache",
    ".svn",
    ".tox",
    ".venv",
    ".vscode",
    "__pypackages__",
    "_build",
    "buck-out",
    "build",
    "dist",
    "node_modules",
    "site-packages",
    "venv",
]

line-length = 80
indent-width = 4


[tool.ruff.lint]
select = [
    "E", # pycodestyle (error)
    "F", # pyflakes
    "B", # bugbear
    "B9",
    "C4", # flake8-comprehensions
    "SIM", # flake8-simplify
    "I", # isort
    "UP", # pyupgrade
    "PIE", # flake8-pie
    "PGH", # pygrep-hooks
    "PYI", # flake8-pyi
    "RUF",
]
ignore = [
    # Ignoring russian comments
    "RUF001",
    "RUF002",
    "RUF003",
    "PGH003",
    # Unused imports
    "F401",
]

[tool.ruff.format]
quote-style = "double"
indent-style = "space"
skip-magic-trailing-comma = false
docstring-code-format = false
docstring-code-line-length = 80
line-ending = "lf"


#########################
# FILE: src/__init__.py #
#########################



#######################
# FILE: src/config.py #
#######################

"""Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð½Ð°ÑÑ‚Ñ€Ð¾ÐµÐº Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ Ð´Ð»Ñ gosplan-mcp."""

from __future__ import annotations

import logging
import os
from typing import Optional

from dotenv import find_dotenv, load_dotenv
from pydantic import Field, ValidationError
from pydantic_settings import BaseSettings

load_dotenv(find_dotenv())

LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL, logging.INFO),
    format="%(asctime)s %(levelname)s %(name)s %(message)s",
)
logger = logging.getLogger("gosplan-mcp")


class Settings(BaseSettings):
    """ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ MCP Ñ‚Ñ€Ð°Ð½ÑÐ¿Ð¾Ñ€Ñ‚Ð°."""

    server_port: int = Field(..., alias="MCP_PORT")
    server_host: str = Field(..., alias="MCP_HOST")


_settings_cache: Optional[Settings] = None


def get_settings() -> Settings:
    """Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ ÐºÑÑˆÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ð¹ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€ Ð½Ð°ÑÑ‚Ñ€Ð¾ÐµÐº."""

    global _settings_cache

    if _settings_cache is None:
        try:
            _settings_cache = Settings()
        except ValidationError as exc:
            logger.error("âŒ Invalid configuration:")
            logger.error(exc)
            raise

    return _settings_cache


#############################
# FILE: src/mcp_instance.py #
#############################

"""Ð•Ð´Ð¸Ð½Ñ‹Ð¹ ÑÐºÐ·ÐµÐ¼Ð¿Ð»ÑÑ€ FastMCP Ð´Ð»Ñ gosplan-mcp."""

from fastmcp import FastMCP

mcp = FastMCP("gosplan-mcp")


#######################
# FILE: src/server.py #
#######################

"""MCP ÑÐµÑ€Ð²ÐµÑ€ Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸ Ð“Ð¾ÑÐŸÐ»Ð°Ð½ Ð¿Ð¾ HTTP."""

from __future__ import annotations

import uvicorn
from starlette.middleware import Middleware
from starlette.middleware.cors import CORSMiddleware

from config import get_settings
from mcp_instance import mcp

settings = get_settings()

print("ðŸ”§ Ð—Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÐ¼ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ñ‹...")
try:
    from tools.gosplan_search import search_purchases
    print("âœ… search_purchases Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½")
except Exception as exc:  # pragma: no cover - Ð¾Ñ‚Ð»Ð°Ð´Ð¾Ñ‡Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
    print(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð° search_purchases: {exc}")
    import traceback

    traceback.print_exc()

try:
    from tools.gosplan_details import get_purchase_details
    print("âœ… get_purchase_details Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½")
except Exception as exc:  # pragma: no cover - Ð¾Ñ‚Ð»Ð°Ð´Ð¾Ñ‡Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
    print(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚Ð° get_purchase_details: {exc}")
    import traceback

    traceback.print_exc()

middleware = [
    Middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["GET", "POST", "DELETE", "OPTIONS"],
        allow_headers=[
            "mcp-protocol-version",
            "mcp-session-id",
            "Authorization",
            "Content-Type",
        ],
        expose_headers=["mcp-session-id"],
    )
]

app = mcp.http_app(middleware=middleware)


def main() -> None:
    """Ð—Ð°Ð¿ÑƒÑÐºÐ°ÐµÑ‚ MCP ÑÐµÑ€Ð²ÐµÑ€ Ñ HTTP Ñ‚Ñ€Ð°Ð½ÑÐ¿Ð¾Ñ€Ñ‚Ð¾Ð¼ Ð¸ CORS."""

    print("=" * 60)
    print("ðŸŒ Ð—ÐÐŸÐ£Ð¡Ðš MCP Ð¡Ð•Ð Ð’Ð•Ð Ð (HTTP + CORS)")
    print("=" * 60)
    print(f"ðŸš€ MCP Server: http://{settings.server_host}:{settings.server_port}/mcp")
    print(f"ðŸ“Š ÐœÐµÑ‚Ñ€Ð¸ÐºÐ¸:    http://{settings.server_host}:{settings.server_port}/metrics")
    print(f"ðŸ¥ Health:     http://{settings.server_host}:{settings.server_port}/health")
    print("ðŸ”§ Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ MCP Inspector (Connection Type: Direct)")
    print("=" * 60)
    print("â³ Ð—Ð°Ð¿ÑƒÑÐºÐ°ÐµÐ¼ Uvicorn...")

    try:
        uvicorn.run(
            app,
            host=settings.server_host,
            port=settings.server_port,
        )
    except KeyboardInterrupt:  # pragma: no cover - Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° Ñ‡ÐµÑ€ÐµÐ· Ctrl+C
        print("\nðŸ›‘ ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½ ÑÐ¸Ð³Ð½Ð°Ð» Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ¸ (Ctrl+C)")
        print("ðŸ”„ Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ graceful shutdown...")
        print("âœ… Ð¡ÐµÑ€Ð²ÐµÑ€ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½")
    except Exception as exc:  # pragma: no cover - Ð¾Ñ‚Ð»Ð°Ð´Ð¾Ñ‡Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ
        print(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð¿ÑƒÑÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°: {exc}")
        import traceback

        traceback.print_exc()


if __name__ == "__main__":
    main()


##########################################
# FILE: src/middleware/tmp_middleware.py #
##########################################



###############################
# FILE: src/tools/__init__.py #
###############################



######################################
# FILE: src/tools/gosplan_details.py #
######################################

"""Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð´ÐµÑ‚Ð°Ð»ÐµÐ¹ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸ Ð¿Ð¾ Ð½Ð¾Ð¼ÐµÑ€Ñƒ."""

import httpx
from fastmcp import Context
from mcp.shared.exceptions import ErrorData, McpError
from mcp.types import TextContent
from opentelemetry import trace
from pydantic import Field, ValidationError

from mcp_instance import mcp
from .models import GetPurchaseDetailsRequest, Purchase
from .utils import ToolResult, format_api_error, format_purchase_details

tracer = trace.get_tracer(__name__)


@mcp.tool(
    name="get_purchase_details",
    description="""ðŸ“‹ ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð´ÐµÑ‚Ð°Ð»ÑŒÐ½Ð¾Ð¹ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸ Ð¾ Ð³Ð¾ÑÑƒÐ´Ð°Ñ€ÑÑ‚Ð²ÐµÐ½Ð½Ð¾Ð¹ Ð·Ð°ÐºÑƒÐ¿ÐºÐµ

ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÑ‚ Ð¿Ð¾Ð»Ð½ÑƒÑŽ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾ ÐºÐ¾Ð½ÐºÑ€ÐµÑ‚Ð½Ð¾Ð¹ Ð·Ð°ÐºÑƒÐ¿ÐºÐµ Ð¿Ð¾ ÐµÑ‘ Ð½Ð¾Ð¼ÐµÑ€Ñƒ, Ð²ÐºÐ»ÑŽÑ‡Ð°Ñ:
- ÐŸÐ¾Ð»Ð½Ð¾Ðµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð¿Ñ€ÐµÐ´Ð¼ÐµÑ‚Ð° Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸
- Ð’ÑÐµ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ñ‹ Ñ Ð¾Ñ€Ð¸Ð³Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¼Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸
- ÐœÐµÑÑ‚Ð° Ð¿Ð¾ÑÑ‚Ð°Ð²ÐºÐ¸
- Ð¡Ð²ÑÐ·Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ð»Ð°Ð½Ñ‹ Ð·Ð°ÐºÑƒÐ¿Ð¾Ðº

ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹:
- purchase_number: ÐÐ¾Ð¼ÐµÑ€ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸ (Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ð¹)
""",
)
async def get_purchase_details(
    ctx: Context,
    purchase_number: str = Field(..., description="ÐÐ¾Ð¼ÐµÑ€ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸"),
) -> ToolResult:
    """Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ Ð¿Ð¾Ð´Ñ€Ð¾Ð±Ð½Ð¾ÑÑ‚Ð¸ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸ Ð¿Ð¾ ÐµÑ‘ Ð½Ð¾Ð¼ÐµÑ€Ñƒ."""

    with tracer.start_as_current_span("get_purchase_details") as span:
        span.set_attribute("purchase_number", purchase_number)

        await ctx.info(f"ðŸ“‹ ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÐ¼ Ð´ÐµÑ‚Ð°Ð»Ð¸ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸ {purchase_number}")
        await ctx.report_progress(progress=0, total=100)

        try:
            try:
                GetPurchaseDetailsRequest(purchase_number=purchase_number)
            except ValidationError as exc:
                span.set_attribute("error", "validation_error")
                await ctx.error(f"âŒ ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð½Ð¾Ð¼ÐµÑ€ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸: {exc}")
                raise McpError(
                    ErrorData(
                        code=-32602, message=f"ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð½Ð¾Ð¼ÐµÑ€ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸: {exc}"
                    )
                ) from exc

            await ctx.info("ðŸ”§ ÐŸÐ¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²ÐºÐ° Ð·Ð°Ð¿Ñ€Ð¾ÑÐ°")
            await ctx.report_progress(progress=25, total=100)

            await ctx.info("ðŸ“¡ ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ðº API Ð“Ð¾ÑÐŸÐ»Ð°Ð½")
            await ctx.report_progress(progress=50, total=100)

            async with httpx.AsyncClient(timeout=20.0) as client:
                response = await client.get(
                    f"https://v2test.gosplan.info/fz223/purchases/{purchase_number}"
                )

                if response.status_code == 404:
                    span.set_attribute("error", "not_found")
                    await ctx.error(
                        f"âŒ Ð—Ð°ÐºÑƒÐ¿ÐºÐ° Ñ Ð½Ð¾Ð¼ÐµÑ€Ð¾Ð¼ {purchase_number} Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð°"
                    )

                    raise McpError(
                        ErrorData(
                            code=-32602,
                            message=(
                                f"Ð—Ð°ÐºÑƒÐ¿ÐºÐ° Ñ Ð½Ð¾Ð¼ÐµÑ€Ð¾Ð¼ {purchase_number} Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð° Ð² Ð±Ð°Ð·Ðµ Ð“Ð¾ÑÐŸÐ»Ð°Ð½"
                            ),
                        )
                    )

                response.raise_for_status()
                purchase_data = response.json()

            await ctx.report_progress(progress=75, total=100)

            try:
                purchase = Purchase(**purchase_data)
            except ValidationError as exc:
                span.set_attribute("error", "parse_error")
                await ctx.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð°Ñ€ÑÐ¸Ð½Ð³Ð° Ð¾Ñ‚Ð²ÐµÑ‚Ð° API: {exc}")

                raise McpError(
                    ErrorData(
                        code=-32603,
                        message=f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ð¾Ñ‚Ð²ÐµÑ‚Ð° API: {exc}",
                    )
                )

            formatted_text = format_purchase_details(purchase.model_dump())

            await ctx.report_progress(progress=100, total=100)
            await ctx.info("âœ… Ð”ÐµÑ‚Ð°Ð»Ð¸ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ñ‹")

            span.set_attribute("success", True)
            span.set_attribute("documents_count", len(purchase.docs))
            span.set_attribute("stage", purchase.stage)

            return ToolResult(
                content=[TextContent(type="text", text=formatted_text)],
                structured_content=purchase.model_dump(),
                meta={
                    "purchase_number": purchase_number,
                    "documents_count": len(purchase.docs),
                    "stage": purchase.stage,
                },
            )

        except httpx.HTTPStatusError as exc:
            span.set_attribute("error", "http_status_error")
            span.set_attribute("status_code", exc.response.status_code)

            error_message = format_api_error(
                exc.response.text if exc.response else "",
                exc.response.status_code if exc.response else 0,
            )

            await ctx.error(f"âŒ HTTP Ð¾ÑˆÐ¸Ð±ÐºÐ°: {error_message}")

            raise McpError(
                ErrorData(
                    code=-32603,
                    message=(
                        "ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð´ÐµÑ‚Ð°Ð»Ð¸ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸.\n\n"
                        f"{error_message}"
                    ),
                )
            )

        except httpx.TimeoutException as exc:
            span.set_attribute("error", "timeout")
            await ctx.error("âŒ ÐŸÑ€ÐµÐ²Ñ‹ÑˆÐµÐ½Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð¾Ñ‚Ð²ÐµÑ‚Ð° Ð¾Ñ‚ API")

            raise McpError(
                ErrorData(
                    code=-32603,
                    message="ÐŸÑ€ÐµÐ²Ñ‹ÑˆÐµÐ½Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð¾Ñ‚Ð²ÐµÑ‚Ð° Ð¾Ñ‚ API",
                )
            ) from exc

        except httpx.RequestError as exc:
            span.set_attribute("error", "request_error")
            await ctx.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð¿Ñ€Ð¾ÑÐ°: {exc}")

            raise McpError(
                ErrorData(
                    code=-32603, message="ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ðº API"
                ),
            ) from exc

        except Exception as exc:  # pragma: no cover - Ð¾Ñ‚Ð»Ð°Ð´Ð¾Ñ‡Ð½Ð°Ñ Ð·Ð°Ñ‰Ð¸Ñ‚Ð°
            span.set_attribute("error", "unexpected_error")
            await ctx.error(f"âŒ ÐÐµÐ¿Ñ€ÐµÐ´Ð²Ð¸Ð´ÐµÐ½Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°: {exc}")
            raise


#####################################
# FILE: src/tools/gosplan_search.py #
#####################################

"""Ð˜Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚ Ð¿Ð¾Ð¸ÑÐºÐ° Ð³Ð¾ÑÑƒÐ´Ð°Ñ€ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ñ… Ð·Ð°ÐºÑƒÐ¿Ð¾Ðº Ð¿Ð¾ 223-Ð¤Ð—."""

from datetime import datetime

import httpx
from fastmcp import Context
from mcp.shared.exceptions import ErrorData, McpError
from mcp.types import TextContent
from opentelemetry import trace
from pydantic import Field, ValidationError

from mcp_instance import mcp
from .models import PurchaseIndex, SearchPurchasesRequest
from .utils import ToolResult, format_api_error, format_purchase_list

tracer = trace.get_tracer(__name__)


@mcp.tool(
    name="search_purchases",
    description="""ðŸ” ÐŸÐ¾Ð¸ÑÐº Ð³Ð¾ÑÑƒÐ´Ð°Ñ€ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ñ… Ð·Ð°ÐºÑƒÐ¿Ð¾Ðº Ð¿Ð¾ 223-Ð¤Ð—

Ð˜Ñ‰ÐµÑ‚ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸ Ð² ÑÐ¸ÑÑ‚ÐµÐ¼Ðµ Ð“Ð¾ÑÐŸÐ»Ð°Ð½, Ð¿Ð¾ ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¼ Ð¼Ð¾Ð¶Ð½Ð¾ Ð¿Ð¾Ð´Ð°Ð²Ð°Ñ‚ÑŒ Ð·Ð°ÑÐ²ÐºÐ¸ Ð½Ð° ÑƒÑ‡Ð°ÑÑ‚Ð¸Ðµ.

ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¿Ð¾Ð¸ÑÐºÐ°:
- classifier: ÐšÐ¾Ð´ ÐžÐšÐŸÐ”2 (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, "26.20.11.110" Ð´Ð»Ñ ÐºÐ¾Ð¼Ð¿ÑŒÑŽÑ‚ÐµÑ€Ð¾Ð²)
- submission_close_after: ÐÐ°Ð¹Ñ‚Ð¸ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸ Ñ Ð¾ÐºÐ¾Ð½Ñ‡Ð°Ð½Ð¸ÐµÐ¼ Ð¿Ð¾Ð´Ð°Ñ‡Ð¸ Ð·Ð°ÑÐ²Ð¾Ðº ÐŸÐžÐ¡Ð›Ð• ÑÑ‚Ð¾Ð¹ Ð´Ð°Ñ‚Ñ‹ (ISO format)
- submission_close_before: ÐÐ°Ð¹Ñ‚Ð¸ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸ Ñ Ð¾ÐºÐ¾Ð½Ñ‡Ð°Ð½Ð¸ÐµÐ¼ Ð¿Ð¾Ð´Ð°Ñ‡Ð¸ Ð·Ð°ÑÐ²Ð¾Ðº Ð”Ðž ÑÑ‚Ð¾Ð¹ Ð´Ð°Ñ‚Ñ‹ (ISO format)
- region: ÐšÐ¾Ð´ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð° (Ð½Ð°Ð¿Ñ€Ð¸Ð¼ÐµÑ€, 77 Ð´Ð»Ñ ÐœÐ¾ÑÐºÐ²Ñ‹)
- limit: ÐšÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð² (1-100, Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ 20)
- skip: ÐŸÑ€Ð¾Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ð¿ÐµÑ€Ð²Ñ‹Ðµ N Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð² (Ð´Ð»Ñ Ð¿Ð°Ð³Ð¸Ð½Ð°Ñ†Ð¸Ð¸)

ÐŸÐ¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ Ð¸Ñ‰ÐµÑ‚ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸ Ð½Ð° ÑÑ‚Ð°Ð¿Ðµ "Ð¿Ð¾Ð´Ð°Ñ‡Ð° Ð·Ð°ÑÐ²Ð¾Ðº" (stage=1) Ð² Ñ€ÑƒÐ±Ð»ÑÑ… (RUB).
""",
)
async def search_purchases(
    ctx: Context,
    classifier: str | None = Field(None, description="ÐšÐ¾Ð´ ÐžÐšÐŸÐ”2"),
    submission_close_after: str | None = Field(
        None, description="ISO datetime"
    ),
    submission_close_before: str | None = Field(
        None, description="ISO datetime"
    ),
    region: int | None = Field(None, description="ÐšÐ¾Ð´ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð° (1-99)"),
    limit: int = Field(20, ge=1, le=100),
    skip: int = Field(0, ge=0),
) -> ToolResult:
    """ÐŸÐ¾Ð¸ÑÐº Ð³Ð¾ÑÑƒÐ´Ð°Ñ€ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ñ… Ð·Ð°ÐºÑƒÐ¿Ð¾Ðº Ð¿Ð¾ Ð²Ñ…Ð¾Ð´Ð½Ñ‹Ð¼ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ð°Ð¼."""

    with tracer.start_as_current_span("search_purchases") as span:
        span.set_attribute("classifier", classifier or "all")
        span.set_attribute("region", region or "all")
        span.set_attribute("limit", limit)
        span.set_attribute("skip", skip)

        await ctx.info("ðŸ” ÐÐ°Ñ‡Ð¸Ð½Ð°ÐµÐ¼ Ð¿Ð¾Ð¸ÑÐº Ð³Ð¾ÑÑƒÐ´Ð°Ñ€ÑÑ‚Ð²ÐµÐ½Ð½Ñ‹Ñ… Ð·Ð°ÐºÑƒÐ¿Ð¾Ðº")
        await ctx.report_progress(progress=0, total=100)

        try:
            await ctx.info(
                f"ðŸ”§ ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¿Ð¾Ð¸ÑÐºÐ°: ÐžÐšÐŸÐ”2={classifier or 'Ð²ÑÐµ'}, "
                f"Ñ€ÐµÐ³Ð¸Ð¾Ð½={region or 'Ð²ÑÐµ'}"
            )

            try:
                close_after = (
                    datetime.fromisoformat(submission_close_after)
                    if submission_close_after
                    else None
                )
                close_before = (
                    datetime.fromisoformat(submission_close_before)
                    if submission_close_before
                    else None
                )

                request_params = SearchPurchasesRequest(
                    classifier=classifier,
                    submission_close_after=close_after,
                    submission_close_before=close_before,
                    region=region,
                    stage=1,
                    currency_code="RUB",
                    limit=limit,
                    skip=skip,
                )
            except ValueError as exc:
                span.set_attribute("error", "validation_error")
                await ctx.error(f"âŒ ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹: {exc}")
                raise McpError(
                    ErrorData(code=-32602, message=f"ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ðµ Ð¿Ð°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹: {exc}")
                ) from exc

            await ctx.report_progress(progress=25, total=100)

            await ctx.info("ðŸ“¡ ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÐ¼ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ðº API Ð“Ð¾ÑÐŸÐ»Ð°Ð½")
            await ctx.report_progress(progress=50, total=100)

            query_params = {
                k: v
                for k, v in {
                    "classifier": request_params.classifier,
                    "submission_close_after": (
                        request_params.submission_close_after.isoformat()
                        if request_params.submission_close_after
                        else None
                    ),
                    "submission_close_before": (
                        request_params.submission_close_before.isoformat()
                        if request_params.submission_close_before
                        else None
                    ),
                    "region": request_params.region,
                    "stage": request_params.stage,
                    "currency_code": request_params.currency_code,
                    "limit": request_params.limit,
                    "skip": request_params.skip,
                }.items()
                if v is not None
            }

            async with httpx.AsyncClient(timeout=20.0) as client:
                response = await client.get(
                    "https://v2test.gosplan.info/fz223/purchases",
                    params=query_params,
                )
                response.raise_for_status()
                purchases_data = response.json()

            await ctx.report_progress(progress=75, total=100)

            try:
                purchases = [
                    PurchaseIndex(**p) for p in purchases_data
                ]
            except ValidationError as exc:
                span.set_attribute("error", "parse_error")
                await ctx.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ð°Ñ€ÑÐ¸Ð½Ð³Ð° Ð¾Ñ‚Ð²ÐµÑ‚Ð° API: {exc}")
                raise McpError(
                    ErrorData(
                        code=-32603,
                        message=f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸ Ð¾Ñ‚Ð²ÐµÑ‚Ð° API: {exc}",
                    )
                ) from exc

            formatted_text = format_purchase_list(
                purchases=[p.model_dump() for p in purchases],
                total=len(purchases),
            )

            await ctx.report_progress(progress=100, total=100)
            await ctx.info(f"âœ… ÐÐ°Ð¹Ð´ÐµÐ½Ð¾ Ð·Ð°ÐºÑƒÐ¿Ð¾Ðº: {len(purchases)}")

            span.set_attribute("success", True)
            span.set_attribute("results_count", len(purchases))

            return ToolResult(
                content=[TextContent(type="text", text=formatted_text)],
                structured_content=[p.model_dump() for p in purchases],
                meta={"count": len(purchases)},
            )

        except httpx.HTTPStatusError as exc:
            span.set_attribute("error", "http_status_error")
            span.set_attribute("status_code", exc.response.status_code)

            error_message = format_api_error(
                exc.response.text if exc.response else "",
                exc.response.status_code if exc.response else 0,
            )

            await ctx.error(f"âŒ HTTP Ð¾ÑˆÐ¸Ð±ÐºÐ°: {error_message}")

            raise McpError(
                ErrorData(
                    code=-32603,
                    message=f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÑÐ¿Ð¸ÑÐ¾Ðº Ð·Ð°ÐºÑƒÐ¿Ð¾Ðº.\n\n{error_message}",
                )
            ) from exc

        except httpx.TimeoutException as exc:
            span.set_attribute("error", "timeout")
            await ctx.error("âŒ ÐŸÑ€ÐµÐ²Ñ‹ÑˆÐµÐ½Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð¾Ñ‚Ð²ÐµÑ‚Ð° Ð¾Ñ‚ API")

            raise McpError(
                ErrorData(
                    code=-32603,
                    message="ÐŸÑ€ÐµÐ²Ñ‹ÑˆÐµÐ½Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð¾Ð¶Ð¸Ð´Ð°Ð½Ð¸Ñ Ð¾Ñ‚Ð²ÐµÑ‚Ð° Ð¾Ñ‚ API",
                )
            ) from exc

        except httpx.RequestError as exc:
            span.set_attribute("error", "request_error")
            await ctx.error(f"âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð¿Ñ€Ð¾ÑÐ°: {exc}")

            raise McpError(
                ErrorData(code=-32603, message="ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ðº API"),
            ) from exc

        except Exception as exc:  # pragma: no cover - Ð¾Ñ‚Ð»Ð°Ð´Ð¾Ñ‡Ð½Ð°Ñ Ð·Ð°Ñ‰Ð¸Ñ‚Ð°
            span.set_attribute("error", "unexpected_error")
            await ctx.error(f"âŒ ÐÐµÐ¿Ñ€ÐµÐ´Ð²Ð¸Ð´ÐµÐ½Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°: {exc}")
            raise


#############################
# FILE: src/tools/models.py #
#############################

"""Pydantic Ð¼Ð¾Ð´ÐµÐ»Ð¸ Ð´Ð»Ñ Ñ€Ð°Ð±Ð¾Ñ‚Ñ‹ Ñ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸ Ð“Ð¾ÑÐŸÐ»Ð°Ð½."""

import re
from datetime import datetime
from typing import Any

from pydantic import BaseModel, Field, field_validator


class SearchPurchasesRequest(BaseModel):
    """ÐŸÐ°Ñ€Ð°Ð¼ÐµÑ‚Ñ€Ñ‹ Ð¿Ð¾Ð¸ÑÐºÐ° Ð·Ð°ÐºÑƒÐ¿Ð¾Ðº."""

    classifier: str | None = Field(None, description="ÐšÐ¾Ð´ ÐžÐšÐŸÐ”2")
    submission_close_after: datetime | None = Field(
        None, description="ÐžÐºÐ¾Ð½Ñ‡Ð°Ð½Ð¸Ðµ Ð¿Ð¾Ð´Ð°Ñ‡Ð¸ Ð·Ð°ÑÐ²Ð¾Ðº ÐŸÐžÐ¡Ð›Ð• ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¹ Ð´Ð°Ñ‚Ñ‹"
    )
    submission_close_before: datetime | None = Field(
        None, description="ÐžÐºÐ¾Ð½Ñ‡Ð°Ð½Ð¸Ðµ Ð¿Ð¾Ð´Ð°Ñ‡Ð¸ Ð·Ð°ÑÐ²Ð¾Ðº Ð”Ðž ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¹ Ð´Ð°Ñ‚Ñ‹"
    )
    region: int | None = Field(None, ge=1, le=99, description="ÐšÐ¾Ð´ Ñ€ÐµÐ³Ð¸Ð¾Ð½Ð°")
    stage: int = Field(1, description="Ð­Ñ‚Ð°Ð¿ Ð¿Ñ€Ð¾Ð²ÐµÐ´ÐµÐ½Ð¸Ñ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸")
    currency_code: str = Field("RUB", min_length=3, max_length=3)
    limit: int = Field(20, ge=1, le=100)
    skip: int = Field(0, ge=0)

    @field_validator("classifier")
    @classmethod
    def validate_okpd2(cls, value: str | None) -> str | None:
        """ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚, Ñ‡Ñ‚Ð¾ ÐºÐ¾Ð´ ÐžÐšÐŸÐ”2 ÑÐ¾Ð¾Ñ‚Ð²ÐµÑ‚ÑÑ‚Ð²ÑƒÐµÑ‚ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ñƒ xx.yy.zz.qq."""

        if value is None:
            return value
        if not re.match(r"^\d{2}(\.\d{2}){0,3}$", value):
            raise ValueError(f"Invalid OKPD2 format: {value}")
        return value


class GetPurchaseDetailsRequest(BaseModel):
    """Ð—Ð°Ð¿Ñ€Ð¾Ñ Ð½Ð° Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð´ÐµÑ‚Ð°Ð»ÐµÐ¹ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸."""
    purchase_number: str = Field(..., min_length=1, description="ÐÐ¾Ð¼ÐµÑ€ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸")

    """Ð”Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚ Ð¸Ð· ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ¸ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸."""


    """ÐšÑ€Ð°Ñ‚ÐºÐ°Ñ Ð¼Ð¾Ð´ÐµÐ»ÑŒ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸ Ð¸Ð· ÑÐ¿Ð¸ÑÐºÐ°."""
    """Ð”ÐµÑ‚Ð°Ð»ÑŒÐ½Ð°Ñ Ð¼Ð¾Ð´ÐµÐ»ÑŒ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸ Ñ Ð¿Ð¾Ð»Ð½Ñ‹Ð¼ Ð½Ð°Ð±Ð¾Ñ€Ð¾Ð¼ Ð¿Ð¾Ð»ÐµÐ¹."""

    # ÐÐ°ÑÐ»ÐµÐ´ÑƒÐµÑ‚ Ð²ÑÐµ Ð¿Ð¾Ð»Ñ PurchaseIndex, Ð²ÐºÐ»ÑŽÑ‡Ð°Ñ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ñ‹ Ñ Ð¸ÑÑ…Ð¾Ð´Ð½Ñ‹Ð¼Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ð¼Ð¸
    # Ð² Ð¿Ð¾Ð»Ðµ source
    docs: list[PurchaseDocument]
    source: dict[str, Any] | None = None


class PurchaseIndex(BaseModel):
    """07>20O 8=D>@<0F8O > 70:C?:5 (4;O A?8A:0)."""

    submission_close_at: datetime | None = None
    currency_code: str
    customer: str
    delivery_places: list[str] | None = None
    doc_created_at: datetime
    doc_updated_at: datetime
    docs: list[PurchaseDocument]
    max_price: float | None = None
    object_info: str
    okpd2: list[str] | None = None
    region: int
    purchase_number: str
    stage: int
    placer: str | None = None
    plan_numbers: list[str] | None = None
    position_numbers: list[str] | None = None
    published_at: datetime
    purchase_type: str
    updated_at: datetime


class Purchase(PurchaseIndex):
    """>;=0O 8=D>@<0F8O > 70:C?:5 (A 45B0;O<8 4>:C<5=B>2)."""

    # 0A;54C5B 2A5 ?>;O >B PurchaseIndex
    #  docs 1C45B 70?>;=5=> ?>;5 source A ?>;=K<8 40==K<8 4>:C<5=B0


############################
# FILE: src/tools/utils.py #
############################

"""Ð£Ñ‚Ð¸Ð»Ð¸Ñ‚Ñ‹ Ð´Ð»Ñ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ð¾Ñ‚Ð²ÐµÑ‚Ð¾Ð² Ð¸ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ."""

from __future__ import annotations

import json
import os
from dataclasses import dataclass
from typing import Any

from mcp.shared.exceptions import ErrorData, McpError
from mcp.types import TextContent


@dataclass
class ToolResult:
    """Ð¡Ñ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð°Ñ Ð¾Ð±ÐµÑ€Ñ‚ÐºÐ° Ð´Ð»Ñ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð² MCP Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°."""

    content: list[TextContent]
    structured_content: dict[str, Any] | list[dict[str, Any]]
    meta: dict[str, Any]


def check_required_env_vars(required_vars: list[str]) -> None:
    """ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÑ‚, Ñ‡Ñ‚Ð¾ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ Ð·Ð°Ð¿Ð¾Ð»Ð½ÐµÐ½Ñ‹."""

    missing = [var for var in required_vars if not os.getenv(var)]
    if missing:
        raise McpError(
            ErrorData(
                code=-32602,
                message=(
                    "ÐÐµ Ð·Ð°Ð´Ð°Ð½Ñ‹ Ð¾Ð±ÑÐ·Ð°Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð¿ÐµÑ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð¾ÐºÑ€ÑƒÐ¶ÐµÐ½Ð¸Ñ: "
                    + ", ".join(sorted(missing))
                ),
            )
        )


def format_api_error(api_error: str, code: int) -> str:
    """Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÑ‚ ÑƒÐ´Ð¾Ð±Ð¾Ñ‡Ð¸Ñ‚Ð°ÐµÐ¼Ð¾Ðµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð¾ÑˆÐ¸Ð±ÐºÐ¸ API."""

    try:
        parsed = json.loads(api_error) if api_error else {}
    except json.JSONDecodeError:
        parsed = api_error

    if code == 404:
        return "Ð—Ð°Ð¿Ð¸ÑÑŒ Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð°"

    if code == 422:
        details: list[str] = []

        if isinstance(parsed, dict) and "detail" in parsed:
            detail = parsed["detail"]
            if isinstance(detail, list):
                for item in detail:
                    if isinstance(item, dict):
                        location = ".".join(str(part) for part in item.get("loc", []))
                        message = item.get("msg", "ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°")
                        if location:
                            details.append(f"{location}: {message}")
                        else:
                            details.append(message)
                    else:
                        details.append(str(item))
            else:
                details.append(str(detail))
        elif parsed:
            details.append(str(parsed))
        else:
            details.append("ÐžÑˆÐ¸Ð±ÐºÐ¸ Ð²Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸Ð¸")

        return "ÐžÑˆÐ¸Ð±ÐºÐ¸ Ð²Ð°Ð»Ð¸Ð´Ð°Ñ†Ð¸Ð¸:\n  - " + "\n  - ".join(details)

    if isinstance(parsed, dict) and "detail" in parsed:
        return str(parsed["detail"])

    if isinstance(parsed, dict):
        return json.dumps(parsed, ensure_ascii=False)

    return str(api_error) if api_error else "ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ°"


def format_purchase_summary(purchase: dict[str, Any]) -> str:
    """ÐšÑ€Ð°Ñ‚ÐºÐ¾Ðµ Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ð¾Ðµ Ð¿Ñ€ÐµÐ´ÑÑ‚Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸."""

    stage_map = {
        1: "Ð¿Ð¾Ð´Ð°Ñ‡Ð° Ð·Ð°ÑÐ²Ð¾Ðº",
        2: "Ñ€Ð°ÑÑÐ¼Ð¾Ñ‚Ñ€ÐµÐ½Ð¸Ðµ",
        3: "Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ð±ÐµÐ´Ð¸Ñ‚ÐµÐ»Ñ",
        4: "Ð·Ð°ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð´Ð¾Ð³Ð¾Ð²Ð¾Ñ€Ð°",
    }

    okpd2_codes = ", ".join(purchase.get("okpd2") or [])
    close_at = purchase.get("submission_close_at")
    close_at_str = str(close_at) if close_at else "Ð½ÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…"

    max_price = purchase.get("max_price")
    max_price_str = f"{max_price:,.2f}" if max_price else "Ð½ÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…"

    return (
        f"ÐÐ¾Ð¼ÐµÑ€ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸: {purchase.get('purchase_number', 'â€”')}\n"
        f"Ð—Ð°ÐºÐ°Ð·Ñ‡Ð¸Ðº: {purchase.get('customer', 'Ð½ÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…')}\n"
        f"ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ: {purchase.get('object_info', 'Ð½ÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…')}\n"
        f"ÐÐ°Ñ‡Ð°Ð»ÑŒÐ½Ð°Ñ Ñ†ÐµÐ½Ð°: {max_price_str} {purchase.get('currency_code', '')}\n"
        f"ÐžÐºÐ¾Ð½Ñ‡Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¸ÐµÐ¼Ð° Ð·Ð°ÑÐ²Ð¾Ðº: {close_at_str}\n"
        f"Ð¡Ñ‚Ð°Ð´Ð¸Ñ: {stage_map.get(purchase.get('stage'), 'Ð½ÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð¾')}\n"
        f"Ð ÐµÐ³Ð¸Ð¾Ð½: {purchase.get('region', 'Ð½ÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…')}\n"
        f"ÐžÐšÐŸÐ”2: {okpd2_codes or 'Ð½ÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…'}"
    )


def format_purchase_list(purchases: list[dict[str, Any]], total: int) -> str:
    """Ð¤Ð¾Ñ€Ð¼Ð¸Ñ€ÑƒÐµÑ‚ Ñ‚ÐµÐºÑÑ‚Ð¾Ð²Ñ‹Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº Ð·Ð°ÐºÑƒÐ¿Ð¾Ðº Ð´Ð»Ñ Ð¾Ñ‚Ð²ÐµÑ‚Ð° LLM."""

    header = f"Ð’ÑÐµÐ³Ð¾ Ð·Ð°ÐºÑƒÐ¿Ð¾Ðº: {total}\nÐŸÐ¾ÐºÐ°Ð·Ð°Ð½Ð¾: {len(purchases)}\n\n"
    formatted_items = []

    for idx, purchase in enumerate(purchases, start=1):
        formatted_items.append(f"{idx}.\n{format_purchase_summary(purchase)}")

    return header + "\n\n".join(formatted_items)


def format_purchase_details(purchase: dict[str, Any]) -> str:
    """ÐŸÐ¾Ð´Ñ€Ð¾Ð±Ð½Ð¾Ðµ Ð¾Ð¿Ð¸ÑÐ°Ð½Ð¸Ðµ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸ Ñ Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸ÑÐ¼Ð¸ Ð¸ Ð¼ÐµÑÑ‚Ð°Ð¼Ð¸ Ð¿Ð¾ÑÑ‚Ð°Ð²ÐºÐ¸."""

    delivery_places = purchase.get("delivery_places") or []
    if delivery_places:
        text += "\n\nÐœÐµÑÑ‚Ð° Ð¿Ð¾ÑÑ‚Ð°Ð²ÐºÐ¸:\n"
        for place in delivery_places:
    text += f"\n\nÐ”Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ñ‹ Ð·Ð°ÐºÑƒÐ¿ÐºÐ¸ ({len(docs)}):\n"
        doc_type = doc.get("doc_type", "ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ñ‹Ð¹ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚")
        published_at = doc.get("published_at", "Ð½ÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ…")
        text += f"  - {doc_type} (Ð¾Ð¿ÑƒÐ±Ð»Ð¸ÐºÐ¾Ð²Ð°Ð½: {published_at})\n"
    plan_numbers = purchase.get("plan_numbers") or []
    if plan_numbers:
        text += f"\n\nÐ¡Ð²ÑÐ·Ð°Ð½Ð½Ñ‹Ðµ Ð¿Ð»Ð°Ð½Ñ‹ Ð·Ð°ÐºÑƒÐ¿Ð¾Ðº: {', '.join(plan_numbers)}\n"
    text += f"\n\n>:C<5=BK 70:C?:8 ({len(docs)}):\n"
    for doc in docs:
        text += f"  - {doc['doc_type']} (>?C1;8:>20=>: {doc['published_at']})\n"

    # >102;O5< A2O70==K5 ?;0=K
    if purchase.get("plan_numbers"):
        text += (
            f"\n\n!2O70==K5 ?;0=K 70:C?>:: {', '.join(purchase['plan_numbers'])}\n"
        )

    return text


###############################
# FILE: src/utils/__init__.py #
###############################

from .settings import ROOT_DIR, Settings, settings

__all__ = (
    "ROOT_DIR",
    "Settings",
    "settings",

)


###############################
# FILE: src/utils/settings.py #
###############################

from functools import lru_cache
from pathlib import Path

from dynaconf import Dynaconf  # type: ignore[import-untyped]
from pydantic import (
    BaseModel,
    model_validator,
)
from pydantic_settings import BaseSettings

__all__ = (
    "ROOT_DIR",
    "App",
    "Settings",
    "load_settings",
    "settings",
)

ROOT_DIR = Path(__file__).resolve().parent.parent.parent


class App(BaseModel):
    """Application configuration."""

    title: str
    version: str
    root_path: str
    port: int
    host: str
    opentelemetry_available: bool
    otel_endpoint: str
    otel_service_name: str

    @staticmethod
    def __parse_version_from_pyproject_toml() -> str:
        """Parse version from pyproject.toml file."""
        try:
            with open("pyproject.toml") as f:
                for line in f:
                    if line.startswith("version ="):
                        return line.split("=")[1].strip().strip('"')
        except FileNotFoundError:
            return "0.0.0"

        return "0.0.0"

    @model_validator(mode="after")
    def set_version_from_pyproject(self) -> "App":
        """Post-initialization to set default values."""
        temp = self.version
        parsed_version = self.__parse_version_from_pyproject_toml()

        if parsed_version != "0.0.0":
            self.version = parsed_version
        elif self.version == "0.0.0":
            self.version = temp

        return self


class Settings(BaseSettings):
    """Main configuration class."""

    app: App

    # skip extra validation for Dynaconf compatibility
    model_config = {
        "extra": "allow",  # Allow extra fields for Dynaconf compatibility
    }


@lru_cache(maxsize=1)
def load_settings(settings_dir: str | Path | None = None) -> Settings:
    """Load configuration from YAML files using Dynaconf.

    Args:
        settings_dir: Directory containing settings.yml and secrets.yml files.
            Default is the project root directory.

    Returns:
        Settings: Config Pydantic model instance with all settings.
    """
    if settings_dir is None:
        settings_dir = ROOT_DIR

    settings_path = (
        Path(settings_dir) if isinstance(settings_dir, str) else settings_dir
    )

    secrets_file = settings_path / ".secrets.yml"

    # Check if secrets file exists
    if not secrets_file.exists():
        raise FileNotFoundError(f"Settings file not found: {secrets_file}")

    # Prepare list of configuration files
    config_files = [str(secrets_file)]

    # Load configuration using Dynaconf
    dynaconf_settings = Dynaconf(
        settings_files=config_files,
        envvar_prefix="MCP_",
        load_dotenv=True,
        merge_enabled=True,
    )

    # Convert Dynaconf settings to a regular dictionary
    config_data = {k.lower(): v for k, v in dynaconf_settings.to_dict().items()}

    # Create Settings instance directly from config data
    return Settings.model_validate(config_data)


settings = load_settings()


